# ./1 (premiÃ¨res bases)/src/Affichage.java

class Affichage {
	Grille grille;
	int nombre_d_espaces;

	public Affichage (Grille grille) {
		this.grille = grille;
		this.nombre_d_espaces = 3;
	}

	public void affiche () {
		char c = 'A';
		int i, j, h;
		int hauteur = grille.hauteur;
		int largeur = grille.largeur;

		affiche_espaces(nombre_d_espaces+1);
		for (i=0; i<largeur; i++) {
			affnn(""+(i+1));
			if (i>(9-1))
				affiche_espaces(nombre_d_espaces-1);
			else
				affiche_espaces(nombre_d_espaces);
		}
		affiche_sauts_de_ligne(1);

		affiche_sauts_de_ligne(1);
		for (i=0; i<hauteur; i++) {
			affnn(""+(c++));
			affiche_espaces(nombre_d_espaces);
			for (j=0; j<largeur; j++) {
				if (grille.grille[i][j]!=null) {
					affnn(grille.grille[i][j].toString());
					affiche_espaces(1);
				}
				else {
					affnn("0");
					affiche_espaces(nombre_d_espaces);
				}
			}
			affiche_sauts_de_ligne(2);
		}
	}

// ############# Fonctions utilitaires d'affichage ################ //


// ################### Fonctions utilitaires ###################### //

	public void affiche_espaces (int nombre_d_espaces) {
		int i;

		for (i=0; i<nombre_d_espaces; i++) {
			affnn(" ");
		}
	}

	public void affiche_sauts_de_ligne (int nombre_de_lignes) {
		int i;

		for (i=0; i<nombre_de_lignes; i++) {
			affnn("\n");
		}
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1 (premiÃ¨res bases)/src/Bateau.java

class Bateau {
	int nombre_de_cases;
	int nombre_de_cases_restantes;
	int joueur;

	// Utilitaire
	Menu menu;

	/**
		int joueur : numéro du joueur
	**/
	public Bateau (int nombre_de_cases, int joueur) {
		menu = new Menu();
		this.nombre_de_cases = nombre_de_cases;
		this.nombre_de_cases = nombre_de_cases_restantes;
		this.joueur = joueur;
	}

// ######## Fonctions utilitaires pour les bateaux ######### //

// ###************** Placement des bateaux **************### //

	public int nombre_de_place_de_bateau (int nombre_de_joueurs, 
		int proposition, int hauteur, int largeur) {
		int nombre_de_cases_total = hauteur*largeur;
		int max_autorise = nombre_de_place_de_bateau_max(nombre_de_joueurs, 
								hauteur, largeur);

		if (proposition<max_autorise) return proposition;
		else return max_autorise;
	}

	/**
		Renvoie le nombre de cases max.

		Soit n le nombre de joueurs
		et m le nombre de cases total
		de la grille.

		Calcul : res = (1/(n+1))*m
	**/
	public int nombre_de_place_de_bateau_max (int nombre_de_joueurs, 
		int hauteur, int largeur) {

		int nombre_de_cases_total = hauteur*largeur;
		int max_autorise = (int)((1.0/(nombre_de_joueurs+1))*nombre_de_cases_total);

		return max_autorise;
	}

	/**
		Donne la taille max d'un bateau
		en fonction du nombre de cases restant.
	**/
	public int taille_max_bateau (int nombre_de_cases_restant, 
		int proposition, int hauteur, int largeur) {
		int max_hauteur_largeur = Math.min(hauteur, largeur);

		if (proposition<nombre_de_cases_restant) {
			if (proposition>max_hauteur_largeur) return max_hauteur_largeur;
			else return proposition;
		}
		else return nombre_de_cases_restant;
	}

	/**
		Donne les bateaux d'un joueur
		Chaque case du tableau int[] 
		contient le nombre du case d'un bateau.
	**/
	public int [] donne_les_bateaux (int nombre_de_joueurs, int hauteur, int largeur) {
		int nombre_de_place_de_bateau_max = nombre_de_place_de_bateau_max(nombre_de_joueurs, hauteur, largeur);

		int [] res = menu.entre_nombre_de_case_bateau(nombre_de_place_de_bateau_max);		

		return res;
	}

// ###********************* Attaque *********************### //

	public void attaque () {
		this.nombre_de_cases_restantes = this.nombre_de_cases_restantes-1;
	}

// ################# Fonctions d'affichage ################# //

	public String toString() {
		String res = "B"+joueur;
		return res;
	}

// ################### Fonctions utilitaires ###################### //

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1 (premiÃ¨res bases)/src/Grille.java

class Grille {
	public int hauteur;
	public int largeur;

	Utilitaire u;
	public Bateau [][] grille;

	public Grille (int hauteur, int largeur) {
		u = new Utilitaire();
		this.hauteur = hauteur;
		this.largeur = largeur;
		this.grille = new Bateau[hauteur][largeur];
	}

	public void initialisation_de_la_grille () {
		int i, j;

		for (i=0; i<hauteur; i++) {
			for (j=0; j<largeur; j++) {
				grille[i][j] = null;
			}
		}
	}

// ###################### Attaquer une case ####################### //

	/**
		renvoie un boolean :
			true : touché
			false : "dans l'eau !"			
	**/
	public boolean attaquer_une_case (int ordonnee, int abscisse) {
		// "Dans l'eau !"
		if (grille[ordonnee][abscisse]==null) return false;
		// touché
		else {
			grille[ordonnee][abscisse].attaque();
			return true;
		}
	}

// ###################### Ajout d'un bateau ####################### //

	/**
		int nombre_de_cases : nombre de cases du bateau
		int joueur : numéro du joueur
	**/
	public void ajoute_un_bateau_une_case (int ordonnee, int abscisse, int nombre_de_cases, int joueur) {
		grille[ordonnee][abscisse] = new Bateau(nombre_de_cases, joueur);
	}

	/*public void ajoute_bateau (int case_1, int cas_fin) {
		int i;

		for (i=0; i<
	}*/

//################ Fonctions utilitaires du jeu ################//

// ################### Fonctions utilitaires ###################### //

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1 (premiÃ¨res bases)/src/Jeu.java

class Jeu {
	Grille grille;
	int nombre_de_joueurs;

	// Utilitaire
	Utilitaire u;
	Affichage affichage;
	Menu menu;

	public Jeu (int hauteur, int largeur, int nombre_de_joueurs) {
		u = new Utilitaire();
		menu = new Menu();
		this.nombre_de_joueurs = nombre_de_joueurs;
		grille = new Grille(hauteur, largeur);
		affichage = new Affichage(grille);
		affichage.affiche();

	// ####################### Tests ########################## //

		/*int [] tmp = menu.donne_cases_bateau (1, 2, grille.hauteur);
		aff("ordonnée case 1 : "+tmp[0]);
		aff("abscisse case 1 : "+tmp[1]);
		aff("ordonnée case fin : "+tmp[2]);
		aff("abscisse case fin : "+tmp[3]);*/

		int choix;
		while (true) {
			choix = menu.menu_principal();
			if (choix==3) System.exit(0);
		}
		// A continuer...
	}

	public void initialisation_du_jeu () {

	}

	public void partie () {

	}















// ################# Fonctions utiliaires du jeu ################## //

	public void placer_un_bateau (int case_debut, int case_fin, int nombre_de_cases) {
		
	}

// ############################## Main ############################ //

	public static void main (String [] args) {
		Jeu jeu = new Jeu(5, 5, 1);
	}

// ################### Fonctions utilitaires ###################### //

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1 (premiÃ¨res bases)/src/Menu.java

import java.util.Scanner;

class Menu {
	Utilitaire u;

	public Menu() {
		Utilitaire u = new Utilitaire();
	}

	public int menu_principal () {
		int res = -1;
		aff("\n   ******* Menu principal ******* \n");
		while (res!=1 && res!=2 && res!=3) {
			aff("\t1 : Jeu humain");
			aff("\t2 : Jeu IA (ordinateur contre ordinateur)");
			aff("\t3 : Quitter");
			affnn("\n   ");
			res = entrer_entier("entre 1 et 3");
		}
		return res;
	}

// ###################### Fonctions du jeu ######################## //

// ###******** Fonctions de positionnements des bateaux ********### //

	public int entre_nombre_de_bateaux (int nombre_de_cases_restantes) {
		int res = -1;

		while (res<1 || res>nombre_de_cases_restantes) {
			res = entrer_entier_phrase("inférieur ou égal à "+nombre_de_cases_restantes+" et suppérieur à 0");
		}
		return res;
	}

	public int entre_nombre_de_case_bateau (int nombre_de_cases_restantes, int nombre_de_bateaux_restants) {
		int res = -1;
		int chiffre_a_entrer_inferieur_a = nombre_de_cases_restantes-(nombre_de_bateaux_restants-1);
		while (res<1 || res>chiffre_a_entrer_inferieur_a) {
			res = entrer_entier_phrase("inférieur ou égal à "+chiffre_a_entrer_inferieur_a+" et suppérieur à 0");
		}
		return res;
	}

	/**
		Donne les bateaux d'un joueur
		Chaque case du tableau int[] 
		contient le nombre du case d'un bateau.
	**/
	public int[] entre_nombre_de_case_bateau (int nombre_de_cases_restantes) {
		int i;
		int tmp;
		int [] res;
		int nombre_de_cases_restantes_tmp = nombre_de_cases_restantes;
		int nombre_de_bateaux_restants;

		aff("Il vous reste "+nombre_de_cases_restantes+" cases à occuper avec vos bateaux.");
		aff("Veuillez entrer le nombre de bateaux : ");
		int nombre_de_bateaux = entre_nombre_de_bateaux(nombre_de_cases_restantes);
		nombre_de_bateaux_restants = nombre_de_bateaux;
		res = new int[nombre_de_bateaux];
		for (i=0; i<nombre_de_bateaux ; i++) {
			tmp = entre_nombre_de_case_bateau(nombre_de_cases_restantes_tmp, nombre_de_bateaux_restants);
			res[i] = tmp;
			nombre_de_cases_restantes_tmp-=tmp;
			nombre_de_bateaux_restants--;
		}
		return res;
	}

	/**
		Donne la pemière et la dernière case 
		du bateau.
		Renvoie un int [] :
			int[0] : première case, ordonnée
			int[1] : première case, abscisse
			int[2] : deuxième case, ordonnée
			int[3] : deuxième case, abscisse
	**/
	public int [] donne_cases_bateau (int numero_du_bateau, int nombre_de_cases_bateau, int hauteur) {
		String message = "Entrer la première case du bateau numéro "+numero_du_bateau+" à "+nombre_de_cases_bateau+" case(s) : ";
		int [] case1 = entre_case(message, numero_du_bateau, hauteur);
		message = "Entrer la dernière case du bateau numéro "+numero_du_bateau+" à "+nombre_de_cases_bateau+" case(s) : ";
		int [] case_fin = entre_case(message, numero_du_bateau, hauteur);
		int [] res = new int[4];

		res[0] = case1[0];
		res[1] = case1[1];
		res[2] = case_fin[0];
		res[3] = case_fin[1];

		return res;
	}

	public int [] entre_case (String message, int numero_du_bateau, int hauteur) {
		int i = 0;
		Scanner sc = new Scanner(System.in);
		u = new Utilitaire();
		String reponse = "";
		aff(message);
		while (!u.verifie_format_case(reponse, hauteur)) {
			if (i>0 && !u.verifie_format_case(reponse, hauteur))
				aff("Format de case incorrect");
			reponse = sc.nextLine();
			i++;
		}
		return u.convertit_case_en_coordonnee(reponse, hauteur);
	}

// ################### Fonctions utilitaires ###################### //

	public int entrer_entier (String precision) {
		Scanner sc = new Scanner(System.in);
		u = new Utilitaire();
		String res = "";

		affnn("? = ");
		res = sc.nextLine();
		while (!u.is_integer(res)) {
			aff("Veuillez entrer en entier "+precision+" : ");
			affnn("? = ");
			res = sc.nextLine();
		}
		return Integer.parseInt(res);
	}

	public int entrer_entier_phrase (String precision) {
		Scanner sc = new Scanner(System.in);
		String res = "";

		aff("Veuillez entrer en entier "+precision+" : ");
		affnn("? = ");
		res = sc.nextLine();
		while (!is_integer(res)) {
			aff("Veuillez entrer en entier "+precision+" : ");
			affnn("? = ");
			res = sc.nextLine();
		}
		return Integer.parseInt(res);
	}

	public boolean is_integer (String s0) {
		try {
			int n1 = Integer.parseInt(s0);
			return true;
		}
		catch (Exception e) {
			return false;
		}
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1 (premiÃ¨res bases)/src/Utilitaire.java

class Utilitaire {

	public Utilitaire() {}

//################ Fonctions utilitaires du jeu ################//

	public boolean tmp () {
		return true;
	}

	/**
		Format correct : A5.
	**/
	public boolean verifie_format_case (String s0, int hauteur) {
		char tmp, tmp2;
		if (s0==null) return false;
		if (s0.length()==2) {
			tmp = s0.charAt(0);
			if (tmp>='A' && tmp<=('A'+(hauteur-1))) {
				tmp2 = s0.charAt(1);
				if (is_integer(""+tmp2)) return true;
				else return false;
			} else return false;
		} else return false;
	}

	/**
		On donne des coordonnées type A5
		et la fonction donne 1, 5 pour A5
	**/
	public int [] convertit_case_en_coordonnee (String s0, int hauteur) {
		int [] res = new int[2];
		char c='A';
		int ordonnee;
		int abscisse;

		if (verifie_format_case(s0, hauteur)) {
			ordonnee = (int)(s0.charAt(0)-(int)('A')+1);
			abscisse = (int)(s0.charAt(1)-(int)('0'));
			res[0] = ordonnee;
			res[1] = abscisse;
		}
		else {
			aff("convertit_case_en_coordonnee : Format incorrect");
			return null;
		}

		return res;
	}

	public boolean compare_coordonneee (int ordonnee_source, int abscisse_source, int ordonnee_but, int abscisse_but) {
		return (ordonnee_source==ordonnee_but &&
			abscisse_source==abscisse_but);
	}

	/**
		Un bateau peut être soit horizontal ou vertical soit oblique.
		Cas :

		case_fin est égale à case_1
		case_fin à gauche de case_1
		case_fin à droite de case_1
		case_fin en haut de case_1
		case_fin en bas de case_1		
	**/
	public boolean verifie_placement_bateau (int [] case_1, int [] case_fin, int nombre_de_cases) {
		int tmp = 0;

		if (case_1[0]==case_fin[0] && case_1[1]==case_fin[1]) {
			if (nombre_de_cases==1) return true;
			else return false;
		}
		//Horizontal
		if (case_1[0]==case_fin[0]) {
			//case_fin en haut de case_1
			if (case_fin[1]<case_1[1]) {
				tmp = case_1[1]-case_fin[1];
				if (tmp==nombre_de_cases && tmp>0) return true;
				else return false;
			}
			//case_fin en bas de case_1
			if (case_fin[1]>case_1[1]) {
				tmp = case_fin[1]-case_1[1];
				if (tmp==nombre_de_cases && tmp>0) return true;
				else return false;
			}
		}
		//Vertical
		if (case_1[1]==case_fin[1]) {
			//case_fin à gauche de case_1
			if (case_fin[0]<case_1[0]) {
				tmp = case_1[1]-case_fin[1];
				if (tmp==nombre_de_cases && tmp>0) return true;
				else return false;
			}
			//case_fin à droite de case_1
			if (case_fin[0]>case_1[0]) {
				tmp = case_fin[1]-case_1[1];
				if (tmp==nombre_de_cases && tmp>0) return true;
				else return false;
			}
		}
		return false;
	}

//################### Fonctions utilitaires ####################//

	public boolean is_integer (String s0) {
		try {
			int n1 = Integer.parseInt(s0);
			return true;
		}
		catch (Exception e) {
			return false;
		}
	}

	public int randInt (int min, int max) {
		int res = (int)(Math.random()*max)+min;
		if (res>max) res = max;
		if (res<min) res = min;

		return res;
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1.2 (Jeu finit)/src/Affichage.java

class Affichage {
	int nombre_d_espaces;

	public Affichage () {
		this.nombre_d_espaces = 5;
	}

	public void afficher_carte_attaque_joueur (int [][] plateau, int numero_du_joueur) {
		char charactere = 'A';
		String tmp_str_1="";
		int i, j, h;
		int tmp_int_1 = 1;
		int hauteur = plateau.length;
		int largeur = plateau[0].length;

		aff("\nLégende : \n\n  0 : case pas encore attaquée\n  X : Dans l'eau\n  1 : Touché\n  2 : Coulé");
		aff("\nTableau d'attaque du joueur "+numero_du_joueur+" : \n");

		affiche_espaces(nombre_d_espaces+1);
		for (i=0; i<largeur; i++) {
			affnn(""+(i+1));
			if (i>(9-1))
				affiche_espaces(nombre_d_espaces-1);
			else
				affiche_espaces(nombre_d_espaces);
		}
		affiche_sauts_de_ligne(1);

		affiche_sauts_de_ligne(1);
		for (i=0; i<hauteur; i++) {
			affnn(""+(charactere++));
			affiche_espaces(nombre_d_espaces);
			for (j=0; j<largeur; j++) {
				if (plateau[i][j]==-1)
					tmp_str_1 = "0";
				else if (plateau[i][j]==0)
					tmp_str_1 = "X";
				else 
					tmp_str_1 = ""+plateau[i][j];
				tmp_int_1 = 1;
				affnn(tmp_str_1);
				affiche_espaces(nombre_d_espaces-(tmp_int_1-1));
			}
			affiche_sauts_de_ligne(2);
		}
	}

	public void afficher_carte_joueur (Grille grille, Joueur joueur) {
		if (!joueur.carte_a_montrer) return;
		char c = 'A';
		String tmp_str_1="";
		int i, j, h;
		int tmp_int_1 = 1;
		int numero_du_joueur = joueur.get_numero_du_joueur();
		Case [][] plateau = joueur.plateau;
		int hauteur = grille.hauteur;
		int largeur = grille.largeur;

		aff("\nTableau du joueur "+numero_du_joueur+" : \n");

		affiche_espaces(nombre_d_espaces+1);
		for (i=0; i<largeur; i++) {
			affnn(""+(i+1));
			if (i>(9-1))
				affiche_espaces(nombre_d_espaces-1);
			else
				affiche_espaces(nombre_d_espaces);
		}
		affiche_sauts_de_ligne(1);

		affiche_sauts_de_ligne(1);
		for (i=0; i<hauteur; i++) {
			affnn(""+(c++));
			affiche_espaces(nombre_d_espaces);
			for (j=0; j<largeur; j++) {
				if (plateau!=null) {
					tmp_str_1 = plateau[i][j].toString();
					tmp_int_1 = tmp_str_1.length();
					affnn(tmp_str_1);
				}
				else affnn("0");
				affiche_espaces(nombre_d_espaces-(tmp_int_1-1));
			}
			affiche_sauts_de_ligne(2);
		}
	}


// ################### Fonctions utilitaires ###################### //

	public void affiche_espaces (int nombre_d_espaces) {
		int i;

		for (i=0; i<nombre_d_espaces; i++) {
			affnn(" ");
		}
	}

	public void affiche_sauts_de_ligne (int nombre_de_lignes) {
		int i;

		for (i=0; i<nombre_de_lignes; i++) {
			affnn("\n");
		}
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1.2 (Jeu finit)/src/Bateau.java

class Bateau {
	Menu menu;
	int nombre_de_cases;
	boolean touche;
	boolean coule;

	public Case [] cases;

	public Bateau() {
		menu = new Menu();
	}

	/**
		Cases : 
			Liste des cases du plateau 
			sur lesquel est le bateau.
	**/
	public Bateau (Case [] cases) {
		menu = new Menu();
		this.nombre_de_cases = cases.length;
		this.cases = cases;
		touche = false;
		coule = false;
	}

// ######## Fonctions utilitaires pour les bateaux ######### //

// ###************** Placement des bateaux **************### //

	/**
		Renvoie le nombre de cases max.

		Soit n le nombre de joueurs
		et m le nombre de cases total
		de la grille.

		Calcul : res = (1/(n+1))*m
	**/
	public int nombre_de_place_de_bateau_max (Grille grille) {
		int hauteur = grille.hauteur;
		int largeur = grille.largeur;

		int nombre_de_cases_total = hauteur*largeur;
		int max_autorise = (int)((3.0/5.0)*nombre_de_cases_total);

		return max_autorise;
	}

	/**
		Donne la taille max d'un bateau
		en fonction de la hauteur et 
		de la largeur de la grille uniquement.
	**/
	public int taille_max_bateau (Grille grille, int proposition) {
		int hauteur = grille.hauteur;
		int largeur = grille.largeur;
		int max_hauteur_largeur = Math.min(hauteur, largeur);

		if (proposition>max_hauteur_largeur) return max_hauteur_largeur;
		else return proposition;
	}

	/**
		Donne les bateaux d'un joueur
		Chaque case du tableau int[] 
		contient le nombre du case d'un bateau.
	**/
	public int [] donne_nombre_de_cases_bateaux (Grille grille) {
		int nombre_de_place_de_bateau_max = nombre_de_place_de_bateau_max(grille);

		int [] res = menu.entre_nombre_de_case_bateaux(grille, nombre_de_place_de_bateau_max);		

		return res;
	}

// ################ Fonctions utilitaires du jeu ################ //

	public boolean attaque (Case case_a_attaquer) {
		int i;
		Case case_tmp = new Case();
		boolean est_coule;
		if (!case_a_attaquer.contient_case(this.cases, 
						case_a_attaquer)) {
			return false;
		}
		for (i=0; i<cases.length; i++) {
			if (case_tmp.compare_case(cases[i], case_a_attaquer)) {
				cases[i].attaquer();
			}
		}
		this.coule = verifie_coule();		

		return true;
	}

	public boolean verifie_coule () {
		int i;

		for (i=0; i<cases.length; i++) {
			if (!cases[i].est_attaquee()) {
				return false;
			}
		}
		for (i=0; i<cases.length; i++) {
			cases[i].couler();
		}
		return true;
	}

	public boolean est_coule () {
		return coule;
	}

// ################### Fonctions utilitaires ###################### //

	public void aff_cases () {
		int i;

		for (i=0; i<cases.length; i++) {
			aff("Case "+(i+1)+" : \n"+cases[i].aff_case_str());
		}
	}

	public void aff_cases_touchee () {
		int i;

		for (i=0; i<cases.length; i++) {
			if (cases[i].est_attaquee())
				aff("cases["+(i+1)+"] est attaquée");
			else 
				aff("cases["+(i+1)+"] n'est pas attaquée");
		}
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}

}

# ./1.2 (Jeu finit)/src/Case.java

class Case {
	public int ordonnee;
	public int abscisse;
	public Joueur joueur;
	public Bateau bateau;
	public int numero_du_bateau;

	public boolean attaquee;
	public boolean coule;

	/**
		Pour le tableau d'attaque :
		0 : tans l'eau
		1 : touché
		2 : coulé
	**/
	public int etat;

	public Case() {}

	public Case (int ordonnee, int abscisse) {
		constructeur(ordonnee, abscisse);
		this.etat = -1;
	}

	public Case (Joueur joueur, Bateau bateau, int numero_du_bateau, 
						int ordonnee, int abscisse) {
		this.joueur = joueur;
		this.bateau = bateau;
		this.numero_du_bateau = numero_du_bateau;
		constructeur(ordonnee, abscisse);
		this.etat = -1;
	}

	public Case (int ordonnee, int abscisse, int etat) {
		constructeur(ordonnee, abscisse);
		this.etat = etat;
	}

	public void constructeur (int ordonnee, int abscisse) {
		this.ordonnee = ordonnee;
		this.abscisse = abscisse;
		this.attaquee = false;
		this.coule = false;
	}

// ################ Fonctions utilitaires du jeu ################ //

	public boolean est_attaquee() {
		return attaquee;
	}

	public boolean est_coulee() {
		return coule;
	}

	public void attaquer () {
		attaquee = true;
	}

	public void couler () {
		coule = true;
	}

	/**
		Format correct : A5.
	**/
	public boolean verifie_format_case (String s0, int hauteur) {
		char tmp, tmp2;
		if (s0==null) return false;
		if (s0.length()==2) {
			tmp = s0.charAt(0);
			if (tmp>='A' && tmp<=('A'+(hauteur-1))) {
				tmp2 = s0.charAt(1);
				if (is_integer(""+tmp2)) return true;
				else return false;
			} else return false;
		} else return false;
	}

	/**
		On donne des coordonnées type A5
		et la fonction donne 1, 5 pour A5
	**/
	public int [] convertit_case_en_coordonnee (Grille grille, String s0) {
		int [] res = new int[2];
		char c='A';
		int ordonnee;
		int abscisse;

		if (verifie_case_existe(grille, s0)) {
			ordonnee = (int)(s0.charAt(0)-(int)('A')+1);
			abscisse = (int)(s0.charAt(1)-(int)('0'));
			res[0] = ordonnee;
			res[1] = abscisse;
		}
		else {
			aff("convertit_case_en_coordonnee : Format incorrect");
			return null;
		}

		return res;
	}


	public boolean verifie_case_existe (Grille grille, String case_tmp) {
		if (case_tmp==null) return false;
		if (case_tmp.isEmpty()) return false;
		if (case_tmp.length()!=2) return false;
		if (!verifie_format_case(case_tmp, grille.hauteur)) return false;
		int abscisse = (int)(case_tmp.charAt(1)-'1'+1);
		if (abscisse<1 || abscisse>grille.largeur) return false;
		return true;
	}

	/**
		Prend la première case et la dernière case
		et retourne un tableau de cases contenant
		toutes les cases du bateau.
	**/
	public void convertit_case (Case case_1, Case case_fin) {
		
	}

	/**
		Renvoie true si l'une des cases de tab2 est dans tab1.

	**/
	public boolean contient_case (Case [] tab1, Case[] tab2) {
		int i, j;
		Case case_tmp = new Case();

		for (i=0; i<tab1.length; i++) {
			for (j=0; j<tab2.length; j++) {
				if (case_tmp.compare_case(tab1[i], tab2[j])) return true;
			}
		}
		return false;
	}

// ################### Fonctions utilitaires #################### //

	public boolean compare_case (Case case_1, Case case_2) {
		return (case_1.ordonnee==case_2.ordonnee &&
			case_1.abscisse==case_2.abscisse);
	}

	public boolean contient_case (Case [] cases, Case case_a_comparer) {
		int i;

		for (i=0; i<cases.length; i++) {
			if (compare_case(cases[i], 
				case_a_comparer)) return true;
		}
		return false;
	}

	public boolean is_integer (String s0) {
		try {
			int n1 = Integer.parseInt(s0);
			return true;
		}
		catch (Exception e) {
			return false;
		}
	}

	public String aff_case_str () {
		String res="";
		res+="Ordonnee = "+ordonnee+"\n";
		res+="Abscisse = "+abscisse+"\n";
		return res;
	}

	/**
		Donne les coordonnées de la case en format type : A5
	**/
	public String case_format_ecrit() {
		return (new Utilitaire()).convertit_coordonnees_str(ordonnee, abscisse);
	}

	public String toString() {
		String res = "";
		if (joueur!=null) {
			res = "J"+joueur.toString()+"B"+this.numero_du_bateau;
			if (attaquee && !coule) {
				res = "T"+res;
			}
			if (attaquee && coule) {
				res = "C"+res;
			}
		}
		else {
			if (attaquee) {
				res = "X  ";
			}
			else res = "0  ";
		}
		return res;
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}

}

# ./1.2 (Jeu finit)/src/Grille.java


class Grille {
	public int hauteur;
	public int largeur;

	public Grille (int hauteur, int largeur) {
		this.hauteur = hauteur;
		this.largeur = largeur;
	}

// ################### Fonctions utilitaires ###################### //

	public String toString () {
		String res = "";
		res+="Hauteur = "+hauteur+"\n";
		res+="Largeur = "+largeur+"\n";
		return res;
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1.2 (Jeu finit)/src/IA.java

import java.util.Arrays;

class IA {
	public int [][] plateau;
	Utilitaire utilitaire;
	Grille grille;

	public IA () {
		constructeur();
	}

	public IA (Grille grille) {
		this.grille = grille;
		constructeur();
	}

	public void constructeur() {
		utilitaire = new Utilitaire();
	}

	public Joueur place_bateaux_IA (Grille grille, int numero_du_joueur, boolean IA_humain, boolean carte_a_montrer) {
		int i;
		int tmp = 0;

		int nombre_de_gros_bateaux = 0;
		int tentative = 0;
		int tentative_2 = 0;
		Joueur res = null;
		Bateau bateau_tmp = new Bateau();
		int hauteur = grille.hauteur;
		int largeur = grille.largeur;
		int [] nombre_de_cases_bateaux;

		int nombre_de_bateaux = 0;

		int nombre_de_cases_max = bateau_tmp.nombre_de_place_de_bateau_max(grille);
		int min_hauteur_largeur = Math.min(hauteur, largeur);
		int nombre_cases_bateau_max;
		
		int nombre_de_cases_restantes = nombre_de_cases_max;
		while (nombre_de_cases_restantes>0) {
			nombre_de_cases_restantes-=min_hauteur_largeur;
			nombre_de_gros_bateaux++;
		}
		nombre_de_bateaux+=nombre_de_gros_bateaux;
		if ((-nombre_de_cases_restantes)>0) nombre_de_bateaux++;
		if (nombre_de_bateaux<1) nombre_de_bateaux = 1;
		nombre_de_cases_bateaux = new int[nombre_de_bateaux];

		for (i=0; i<nombre_de_bateaux; i++) {
			nombre_de_cases_restantes = nombre_de_cases_max;
			if (nombre_de_gros_bateaux>0) {
				nombre_cases_bateau_max = Math.min(nombre_de_cases_restantes, min_hauteur_largeur);
				//tmp = randInt(1, nombre_cases_bateau_max);
				//tmp = nombre_cases_bateau_max;
				tmp = randInt((int)((4.0/10)*nombre_cases_bateau_max), nombre_cases_bateau_max);
				if (tmp<1) tmp = 1;
				nombre_de_cases_bateaux[i] = tmp;
				nombre_de_cases_restantes-=tmp;
				nombre_de_gros_bateaux--;
			}
			else nombre_de_cases_bateaux[i] = Math.min(nombre_de_cases_restantes, min_hauteur_largeur);
			if (nombre_de_cases_bateaux[i]<1) nombre_de_cases_bateaux[i] = 1;
		}

		this.plateau = cree_plateau_tmp(grille);
		Bateau [] bateaux = new Bateau[nombre_de_bateaux];
		for (i=0; i<nombre_de_bateaux; i++) {
			bateaux[i] = null;
			tentative_2 = 0;
			while (bateaux[i] == null && tentative_2<5) {
				tentative = 0;
				while (bateaux[i] == null && tentative<5) {
					bateaux[i] = place_un_bateau(grille, nombre_de_cases_bateaux[i]);
					tentative++;
				}
				if (bateaux[i] == null) {
					aff("Bateaux numéro "+(i+1)+", "+tentative+" tentative(s) avec "+nombre_de_cases_bateaux[i]+" case(s).");
					nombre_cases_bateau_max = Math.min(nombre_de_cases_bateaux[i], min_hauteur_largeur);
					nombre_de_cases_bateaux[i] = randInt(1, nombre_cases_bateau_max);
					aff("Nouvel essai avec "+nombre_de_cases_bateaux[i]+" case(s).");
				}
				tentative_2++;
			}
			if (bateaux[i] == null) {
				aff("Bateaux numéro "+(i+1)+" dernier essai avec une seule case.");
				tentative = 0;
				nombre_de_cases_bateaux[i] = 1;
				while (bateaux[i] == null && tentative<5) {
					bateaux[i] = place_un_bateau(grille, nombre_de_cases_bateaux[i]);
					tentative++;
				}
			}
			if (bateaux[i] == null) {
				aff("Bateaux numéro "+(i+1)+" : échec avec une seule case.");
			}
			//afficher_plateau();
		}
		bateaux = adapte_le_nombre_de_bateaux(bateaux);
		res = new Joueur(numero_du_joueur, grille, bateaux, IA_humain, carte_a_montrer);

		return res;
	}

	/**
		Si certains bateaux sont nuls dans bateaux[], retourne un 
		nouveau tableau de Bateau sans les Bateau nuls.
	**/
	public Bateau [] adapte_le_nombre_de_bateaux (Bateau [] bateaux) {
		int i, h;
		Bateau [] bateaux_res;
		int nombre_de_bateaux_calcule = 0;

		for (i=0; i<bateaux.length; i++) {
			if (bateaux[i]!=null)
				nombre_de_bateaux_calcule++;
		}
		bateaux_res = new Bateau[nombre_de_bateaux_calcule];
		h = 0;
		for (i=0; i<bateaux.length; i++) {
			if (bateaux[i]!=null) {
				bateaux_res[h++] = bateaux[i];
			}
		}
		return bateaux_res;		
	}

	public boolean vertical_horizontal () {
		int tmp = randInt(0, 100);
		return (tmp<50);
	}

	public Bateau place_un_bateau (Grille grille, int taille_du_bateau) {
		boolean vertical_horizontal = vertical_horizontal ();
		return place_un_bateau_aux(grille, taille_du_bateau, vertical_horizontal);
	}

	/**
		vertical_horizontal :
			True : Vertical
			False : Horizontal
	**/
	public Bateau place_un_bateau_aux (Grille grille, int taille_du_bateau, boolean vertical_horizontal) {
		int i, j;

		Bateau res = null;
		int hauteur = grille.hauteur;
		int largeur = grille.largeur;
		int tmp2;
		Case case_tmp;
		Case [] cases_disponibles;
		Case [] cases = new Case[taille_du_bateau];

		cases_disponibles = cases_disponibles(vertical_horizontal, taille_du_bateau);
		if (cases_disponibles==null) {
			vertical_horizontal = inverse_bool(vertical_horizontal);
			cases_disponibles = cases_disponibles(vertical_horizontal, taille_du_bateau);
		}
		if (cases_disponibles==null) {
			//aff("IA - Place_un_bateau : Plus de cases disponibles");
			return null;
		}
		tmp2 = randInt(0, cases_disponibles.length-1);
		case_tmp = cases_disponibles[tmp2];
		int [] tmp3 = {case_tmp.ordonnee, case_tmp.abscisse};
		ajoute_un_bateau(tmp3, taille_du_bateau, vertical_horizontal);
		//afficher_plateau();
		case_tmp.abscisse+=1;
		case_tmp.ordonnee+=1;

		// Vertical
		if (vertical_horizontal) {
			j = 0;
			for (i=case_tmp.ordonnee; i<case_tmp.ordonnee+taille_du_bateau; i++) {
				cases[j++] = new Case(i, case_tmp.abscisse);
			}
		}
		// Horizontal
		else {
			j = 0;
			for (i=case_tmp.abscisse; i<case_tmp.abscisse+taille_du_bateau; i++) {
				cases[j++] = new Case(case_tmp.ordonnee, i);
			}
		}
		res = new Bateau(cases);

		return res;
	}

	public int [][] cree_plateau_tmp (Grille grille) {
		int i, j;
		int hauteur = grille.hauteur;
		int largeur = grille.largeur;
		
		int [][] tab = new int[hauteur][largeur];
		for (i=0; i<hauteur; i++) {
			for (j=0; j<largeur; j++) {
				tab[i][j] = 0;
			}
		}
		return tab;		
	}

	public void ajoute_un_bateau (int [] tab, int taille_bateau, boolean vertical_horizontal) {
		ajoute_un_bateau_aux (tab, taille_bateau, vertical_horizontal, true);
	}


	public void ajoute_un_bateau_aux (int [] tab, int taille_bateau, boolean vertical_horizontal, boolean distance_autour) {
		int i, j;

		int ordonnee = tab[0];
		int abscisse = tab[1];

		// Vertical
		if (vertical_horizontal) {
			for (i=ordonnee; i<ordonnee+taille_bateau; i++) {
				this.plateau[i][abscisse] = 1;
			}
			if (distance_autour) {
				if (ordonnee-1>=0)
					this.plateau[ordonnee-1][abscisse] = 1;
				if (ordonnee+taille_bateau<this.plateau.length)
					this.plateau[ordonnee+taille_bateau][abscisse] = 1;
				if (abscisse-1>=0) {
					for (i=ordonnee; i<ordonnee+taille_bateau; i++) {
						this.plateau[i][abscisse-1] = 1;
					}
				}
				if (abscisse+1<this.plateau[0].length) {
					for (i=ordonnee; i<ordonnee+taille_bateau; i++) {
						this.plateau[i][abscisse+1] = 1;
					}
				}
			}
		}
		// Horizontal
		else {
			for (i=abscisse; i<abscisse+taille_bateau; i++) {
				this.plateau[ordonnee][i] = 1;
			}
			if (distance_autour) {
				if (abscisse-1>=0)
					this.plateau[ordonnee][abscisse-1] = 1;
				if (abscisse+taille_bateau<this.plateau[0].length)
					this.plateau[ordonnee][abscisse+taille_bateau] = 1;
				if (ordonnee-1>=0) {
					for (i=abscisse; i<abscisse+taille_bateau; i++) {
						this.plateau[ordonnee-1][i] = 1;
					}
				}
				if (ordonnee+1<this.plateau.length) {
					for (i=abscisse; i<abscisse+taille_bateau; i++) {
						this.plateau[ordonnee+1][i] = 1;
					}
				}
			}
		}
	}

	public Case [] cases_disponibles (boolean vertical_horizontal, int taille_du_bateau) {
		int i, j, h;
		int tmp;
		int hauteur;
		int largeur = 0;
		boolean sature = false;
		int nombre_de_cases = 0;
		Case [] cases_disponibles_res;

		int [][] cases_disponibles = 
			cases_disponibles_aux_1(vertical_horizontal, taille_du_bateau);
		tmp = 0;
		for (i = 0; i<cases_disponibles.length; i++) {
			if (cases_disponibles[i]!=null)	{
				tmp++;
				largeur = cases_disponibles[i].length;
			}
		}
		if (tmp==0) {
			//aff("IA - cases_disponibles : plus de cases disponibles.");
			//aff("Détails : \n\tvertical_horizontal = "+vertical_horizontal);
			return null;
		}
		hauteur = cases_disponibles.length;
		nombre_de_cases = 0;
		for (i = 0; i<cases_disponibles.length; i++) {
			for (j=0; j<largeur; j++) {
				if (cases_disponibles[i]!=null)	nombre_de_cases++;
			}
		}
		cases_disponibles_res = new Case[nombre_de_cases];
		h = 0;
		for (i=0; i<hauteur; i++) {
			for (j=0; j<largeur; j++) {
				if (cases_disponibles[i]!=null) {
					// Vertical
					if (vertical_horizontal) {
						cases_disponibles_res[h] = new Case(j, i);
					}
					// Horizontal
					else {
						cases_disponibles_res[h] = new Case(i, j);
					}
					h++;
				}
			}
		}
		return cases_disponibles_res;
	}

	public int [][] cases_disponibles_aux_1 (boolean vertical_horizontal, int taille_du_bateau) {
		int i, j;
		int [] cases_disponibles_tmp;
		int hauteur = this.plateau.length;
		int largeur = this.plateau[0].length;
		int [] ligne_colonne;
		int [][] cases_disponibles;

		// Vertical
		if (vertical_horizontal) {
			ligne_colonne = new int[hauteur];
			cases_disponibles = new int[largeur][];
			for (i=0; i<largeur; i++) {
				for (j=0; j<hauteur; j++) {
					ligne_colonne[j] = this.plateau[j][i];
				}
				cases_disponibles_tmp = scanne_ligne_colonne(ligne_colonne, taille_du_bateau);
				cases_disponibles[i] = cases_disponibles_tmp;
			}
		}
		// Horizontal
		else {
			ligne_colonne = new int[largeur];
			cases_disponibles = new int[hauteur][];
			for (i=0; i<hauteur; i++) {
				for (j=0; j<largeur; j++) {
					ligne_colonne[j] = this.plateau[i][j];
				}
				cases_disponibles_tmp = scanne_ligne_colonne(ligne_colonne, taille_du_bateau);
				cases_disponibles[i] = cases_disponibles_tmp;
			}
		}
		return cases_disponibles;
	}

	public int [] scanne_ligne_colonne (int [] tab, int taille_du_bateau) {
		int i, j, h;
		boolean ok;
		int nombre_de_cases_possibles = 0;
		int [] cases_possibles = null;
		int taille_du_tableau = tab.length;

		for (i=0; i<taille_du_tableau; i++) {
			ok = true;
			if (i+taille_du_bateau<=taille_du_tableau) {
				for (j=i; j<i+taille_du_bateau; j++) {
					if (j<taille_du_tableau) {
						if (tab[j]==1) ok = false;
					}
				}
			}
			else ok = false;
			if (ok) nombre_de_cases_possibles++;
		}
		cases_possibles = new int[nombre_de_cases_possibles];
		h = 0;
		for (i=0; i<taille_du_tableau; i++) {
			ok = true;
			if (i+taille_du_bateau<=taille_du_tableau) {
				for (j=i; j<i+taille_du_bateau; j++) {
					if (j<taille_du_tableau) {
						if (tab[j]==1) ok = false;
					}
				}
			}
			else ok = false;
			if (ok) {
				cases_possibles[h] = i;
				h++;
			}
		}
		if (nombre_de_cases_possibles==0) {
			//aff("IA - scanne_ligne_colonne : aucune case possible : ");
			//aff("Détails : \n\ttaille_du_bateau = "+taille_du_bateau);
			//aff_tab(tab, "tab");
			return null;
		}
		else return cases_possibles;
	}

	public Case [] cases_occupees () {
		int i, j, h;

		Case [] res = null;
		int taille_res = 0;

		for (i=0; i<this.plateau.length; i++) {
			for (j=0; j<this.plateau[i].length; j++) {
				if (this.plateau[i][j]==1) taille_res++;
			}
		}
		res = new Case[taille_res];
		h = 0;
		for (i=0; i<this.plateau.length; i++) {
			for (j=0; j<this.plateau[i].length; j++) {
				if (this.plateau[i][j]==1) res[h] = new Case(i, j);
				h++;
			}
		}
		if (taille_res==0) return null;
		else return res;
	}

	public boolean joueur_un_coup (Joueur joueur_attaquant, Joueur joueur_attaque) {
		return joueur_attaquant.tenter_une_case_IA(joueur_attaque);
	}

	public boolean ligne_cases_possibles (int [] tab) {
		int i;

		for (i=0; i<tab.length; i++) {
			if (tab[i]!=0) return true;
		}
		return false;
	}

	public int [] ligne_cases_possibles_liste (int [] tab) {
		int i, j;
		int taille_res = 0;
		int [] res;

		for (i=0; i<tab.length; i++) {
			if (tab[i]!=0) taille_res++;
		}
		res = new int[taille_res];
		j = 0;
		for (i=0; i<tab.length; i++) {
			if (tab[i]!=0) {
				res[j] = i;
				j++;
			}
		}
		return res;
	}

	public Case [] liste_des_cases_possibles (Joueur joueur_attaquant) {
		int i, j, h;
		int taille_res = 0;
		Case [] res;

		int [][] plateau = joueur_attaquant.genere_plateau_cases_tentees(joueur_attaquant);

		for (i=0; i<plateau.length; i++) {
			for (j=0; j<plateau[i].length; j++) {
				if (plateau[i][j]==-1) taille_res++;
			}
		}
		res = new Case[taille_res];
		h = 0;
		for (i=0; i<plateau.length; i++) {
			for (j=0; j<plateau[i].length; j++) {
				if (plateau[i][j]==-1) {
					res[h] = new Case(i+1, j+1);
					h++;
				}
			}
		}
		return res;	
	}

	public Case genere_une_case_aleat (Joueur joueur_attaquant) {
		Case [] cases_possibles = liste_des_cases_possibles(joueur_attaquant);
		int choix = randInt(0, cases_possibles.length-1);
		return cases_possibles[choix];
	}

//################### Fonctions utilitaires ####################//

	public void afficher_plateau () {
		afficher_plateau_aux("du plateau (IA)", this.plateau);
	}

	public void afficher_plateau_aux (String nom, int [][] plateau) {
		int i, j;
		int [] t = null;
		if (plateau==null) return;
		if (plateau.length<1) return;
		int hauteur = plateau.length;
		int largeur = plateau[0].length;

		aff("\nAffichage "+nom+" : \n");
		for (i=0; i<hauteur; i++) {
			affnn("  ");
			for (j=0; j<largeur; j++) {
				affnn(""+plateau[i][j]+"   ");
			}
			affnn("\n");
		}
		affnn("\n");
	}

	public void aff_tab (int [] tab, String nom) {
		int i;

		if (tab==null) {
			aff("aff_tab : "+nom+" est null");
			return;
		}
		for (i=0; i<tab.length; i++) {
			aff(nom+"["+i+"] = "+tab[i]);
		}
	}

	public boolean inverse_bool (boolean tmp) {
		if (tmp) return false;
		else return true;
	}

	public boolean is_integer (String s0) {
		try {
			int n1 = Integer.parseInt(s0);
			return true;
		}
		catch (Exception e) {
			return false;
		}
	}

	public int randInt (int min, int max) {
		int tmp;

		if (min==max) return min;
		int res = (int)(Math.random()*max)+min;
		if (res>max) res = max;
		if (res<min) res = min;

		return res;
	}

	/**
		sauf est la tableau de valeurs 
		qui ne doit pas être retourné.
		Sauf est situé entre min et max non-inclus
	**/
	public int randInt_sauf (int min, int max, int [] sauf) {
		int i, j;
		int res;
		int tmp0;
		int taille_de_tmp2;
		int tmp3;

		if (sauf==null) return randInt(min, max);
		if (sauf.length==0) return randInt(min, max);

		// Tri le tableau sauf au cas où 
		// cela ne serait pas le cas.
		//utilitaire.aff_tab("sauf", sauf);
		Arrays.sort(sauf);
		utilitaire.aff_tab("sauf", sauf);

		int [] tmp1 = new int[sauf.length+1];
		int [] tmp2;
		if (min+1==sauf[0]) tmp1[0]=min;
		else tmp1[0] = randInt_trie_valeurs(min, sauf[0]);
		if (sauf.length>1) {
			j = 1;
			for (i=0; i<sauf.length-1; i++) {
				int tmp_12 = randInt_trie_valeurs(sauf[i], sauf[i+1]);
				aff("randInt_trie_valeurs("+sauf[i]+", "+sauf[i+1]+") = "+tmp_12);
				tmp1[j] = tmp_12;
				j++;
			}
		}
		if (max-1==sauf[sauf.length-1]) tmp1[tmp1.length-1]=max;
		else tmp1[tmp1.length-1] = randInt_trie_valeurs(sauf[sauf.length-1], max);
		//utilitaire.aff_tab("tmp1", tmp1);
		taille_de_tmp2 = 0;
		for (i=0; i<tmp1.length; i++) {
			if (tmp1[i]>0) taille_de_tmp2++;
		}
		if (taille_de_tmp2==0) {
			//aff("randInt_sauf : tous les chiffres entre min et max sont indisponibles (sont dans sauf)");
			return -1;
		}
		tmp2 = new int[taille_de_tmp2];
		j = 0;
		for (i=0; i<tmp1.length; i++) {
			if (tmp1[i]>0) {
				tmp2[j] = tmp1[i];
				j++;
			}
		}
		utilitaire.aff_tab("tmp2", tmp2);
		tmp3 = randInt(0, tmp2.length-1);
		res = tmp2[tmp3];
		if (res>max) res = max;
		if (res<min) res = min;
		return res;
	}

	/**
		Donne -1 si les valeurs min et max sont consécutives.
	**/
	public int randInt_trie_valeurs (int min, int max) {
		int tmp;
		if (min>max || min==max) {
			if (min>max) {
				//aff("randInt_trie_valeurs : Erreur, min>max");
			}
			else {
				//aff("min==max");
			}
			//aff("min = "+min);
			//aff("max = "+max);
			if ((max+1)==min) return -1;
		}
		if ((min+1)==max || min==max) return -1;
		else return randInt(min, max);
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1.2 (Jeu finit)/src/Jeu.java

class Jeu {
	Menu menu;
	Affichage affichage;
	Utilitaire utilitaire;
	Grille grille;
	Joueur [] joueurs;
	IA ia;

	public Jeu (int hauteur, int largeur, int nombre_de_joueurs) {
		int choix = 1;
		menu = new Menu();
		affichage = new Affichage();
		utilitaire = new Utilitaire();
		grille = new Grille(hauteur, largeur);
		ia = new IA(grille);

		choix = menu.menu_principal();
		//choix = 1;
		if (choix==2)
			nombre_de_joueurs = menu.entre_nombre_de_joueurs();
		initialisation_du_jeu(nombre_de_joueurs);
		jeu(nombre_de_joueurs);
		// Le joueur a choisi de quitter le jeu
		if (choix==3) System.exit(0);
	}

	public void initialisation_du_jeu (int nombre_de_joueurs) {
		int i, q=0;
		boolean joueur_IA_humain;
		boolean carte_a_montrer;
		boolean placement_auto_humain = false;
		

		joueurs = new Joueur[nombre_de_joueurs];
		for (i=0; i<nombre_de_joueurs; i++) {
			joueur_IA_humain = menu.IA_humain((i+1));
			carte_a_montrer = !joueur_IA_humain;
			//joueur_IA_humain = true;
			//if (!joueur_IA_humain)
			//	q = menu.menu_positionnement_bateaux_1((i+1));
			//else q = 2;
			q = 2;
			if (q==2) placement_auto_humain = true;
			joueurs[i] = placement_bateaux ((i+1), placement_auto_humain, joueur_IA_humain, carte_a_montrer);
			affichage.afficher_carte_joueur(grille, joueurs[i]);
		}
	}

	/**
		placement_auto_humain :
			True : automatique
			False : humain
	**/
	public Joueur placement_bateaux (int numero_du_joueur, boolean placement_auto_humain, boolean IA_humain, boolean carte_a_montrer) {
		Joueur res;
		if (!placement_auto_humain)
			res = new Joueur(numero_du_joueur, grille, IA_humain, carte_a_montrer);
		else res = ia.place_bateaux_IA(grille, numero_du_joueur, IA_humain, carte_a_montrer);
		return res;
	}

	public void jeu (int nombre_de_joueurs) {
		int i, j;
		int gagnant;
		int nombre_de_joueurs_ayant_perdu = 0;
		boolean impossible_de_tenter_une_case = false;
		boolean fin_du_jeu = false;

		while (!fin_du_jeu) {
			for (i=0; i<nombre_de_joueurs; i++) {
				for (j=0; j<nombre_de_joueurs; j++) {
					if (i!=j && !fin_du_jeu) {
						// IA
						if (joueurs[i].IA_humain) {
							impossible_de_tenter_une_case = (!joueurs[i].tenter_une_case_IA(joueurs[j]));
						}
						// Humain
						else {
							impossible_de_tenter_une_case = (!joueurs[i].tenter_une_case(joueurs[j]));
						}
						//joueurs[j].affiche_status_bateaux();
						utilitaire.afficher_evenement_coup(joueurs[j].derniere_case_tentee);
						affichage.afficher_carte_joueur (grille, joueurs[j]);
						if (impossible_de_tenter_une_case) {
							joueurs[i].perd();
						}
						if (joueurs[j].a_perdu()) {
							//aff("\nLe joueur "+(j+1)+" a perdu !\n");
							nombre_de_joueurs_ayant_perdu++;
						}
						// Vérifie si le jeu est terminé
						if (nombre_de_joueurs_ayant_perdu==nombre_de_joueurs-1 
									|| impossible_de_tenter_une_case) {
							aff("\nFin du jeu");
							gagnant = utilitaire.recherche_gagnant (this.joueurs)+1;
							if (gagnant>0)
								aff("\nLe gagnant est le joueur "+gagnant+".\n");
							else
								aff("\nIl n'y a aucun gagnant.\n");
							fin_du_jeu = true;
						}
					}
				}
			}
		}
		// Affichage de la carte d'attaque du dernier coup
		for (i=0; i<nombre_de_joueurs; i++) {
			joueurs[i].affiche_plateau_attaquant(joueurs[i]);
		}
			
		// Affichage des cartes des joueurs à la fin du jeu
		for (i=0; i<nombre_de_joueurs; i++) {
			joueurs[i].carte_a_montrer = true;
			affichage.afficher_carte_joueur(grille, joueurs[i]);
		}
	}

// ###################### Main ###################### //

	public static void main (String [] args) {
		Jeu jeu = new Jeu(4, 4, 2);
	}

// ################### Fonctions utilitaires ###################### //

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}	
}

# ./1.2 (Jeu finit)/src/Joueur.java

class Joueur {
	int numero_du_joueur;
	Affichage affichage;
	Menu menu;
	Utilitaire utilitaire;
	public boolean IA_humain;
	public Case [][] plateau;
	public Case [] cases_occupees;
	public Case [] cases_tentees;
	public int cases_tentees_indice;
	public boolean a_perdu;
	Bateau [] bateaux;
	public int derniere_case_tentee;
	Grille grille;
	/**
		true : Monter les deux cartes
		false : ne pas les montrer
	**/
	public boolean carte_a_montrer;

	public Joueur (int numero_du_joueur, Grille grille, boolean IA_humain, boolean carte_a_montrer) {
		constructeur(grille, numero_du_joueur, IA_humain, carte_a_montrer);
		place_bateaux();
	}

	public Joueur (int numero_du_joueur, Grille grille, Bateau[] bateaux, boolean IA_humain, boolean carte_a_montrer) {
		constructeur(grille, numero_du_joueur, IA_humain, carte_a_montrer);
		this.bateaux = bateaux;
		cases_occupees = utilitaire.cases_occuppees(this);
		plateau = utilitaire.construit_plateau(this);
	}

	public void constructeur (Grille grille, int numero_du_joueur, boolean IA_humain, boolean carte_a_montrer) {
		/**
			-1 : Pas de dernière case tentée
			 0 : dans l'eau
			 1 : touché
			 2 : coulé
		**/
		this.IA_humain = IA_humain;
		this.carte_a_montrer = carte_a_montrer;
		derniere_case_tentee = -1;
		a_perdu = false;
		this.grille = grille;
		this.numero_du_joueur = numero_du_joueur;
		utilitaire = new Utilitaire();
		affichage = new Affichage();
		menu = new Menu();
		cases_tentees = new Case[grille.hauteur*grille.largeur];
		cases_tentees_indice = 0;
	}

// ################ Fonctions utilitaires du jeu ################ //

	public Bateau place_bateau (int numero_du_bateau, int nombre_de_cases) {
		boolean placement_correct_incorrect = false;
		Case [] cases;
		int [] cases_bateau = null;
		int [] case_1 = new int[2];
		int [] case_fin = new int[2];
		while (!placement_correct_incorrect) {
			cases_bateau = menu.donne_cases_bateau(grille, numero_du_bateau, nombre_de_cases);
			case_1[0] = cases_bateau[0];
			case_1 [1] = cases_bateau[1];
			case_fin[0] = cases_bateau[2];
			case_fin[1] = cases_bateau[3];

			placement_correct_incorrect = utilitaire.verifie_placement_bateau (case_1, 
									case_fin, nombre_de_cases);
			if (!placement_correct_incorrect) {
				aff("Placement incorrect");
			}
		}
		cases = utilitaire.donne_cases_bateau(cases_bateau, nombre_de_cases);
		Bateau bateau = new Bateau(cases);
		return bateau;
	}

	/**
		Renvoie un int :
		0 : dans l'eau
		1 : touché
		2 : coulé
	**/
	public int attaquer_une_case (Case case_attaquee) {
		int i;
		int ordonnee_attaquee = utilitaire.formate_int(0, grille.hauteur, case_attaquee.ordonnee-1);
		int abscisse_attaquee = utilitaire.formate_int(0, grille.largeur, case_attaquee.abscisse-1);
		int bateau_attaque = -1;
		int derniere_case_tentee = -1;
		Case case_tmp = new Case();
		//aff("case_tmp : "+case_tmp.toString());

		for (i=0; i<cases_occupees.length; i++) {
			if (case_tmp.compare_case(cases_occupees[i], case_attaquee)) {
				cases_occupees[i].attaquer();
				//aff("cases_occupees[i] : "+cases_occupees[i].toString());
				
				derniere_case_tentee = 1;
			}
		}
		for (i=0; i<bateaux.length; i++) {
			if (bateaux[i].attaque(case_attaquee)) {
				bateau_attaque = i;
			}
			if (bateau_attaque!=-1) {
				if (bateaux[bateau_attaque].est_coule()) {
					derniere_case_tentee = 2;
					met_a_jour_plateau_coule();
				}
			}
		}
		plateau[ordonnee_attaquee][abscisse_attaquee].attaquer();
		//aff("plateau[ordonnee_attaquee][abscisse_attaquee] : "+plateau[ordonnee_attaquee][abscisse_attaquee].toString());
		if (derniere_case_tentee==-1) {
			this.derniere_case_tentee = 0;
			return 0;
		}
		else {
			this.derniere_case_tentee = derniere_case_tentee;
			return derniere_case_tentee;
		}
	}

	public void place_bateaux () {
		int i;
		boolean ok=false;
		Case case_tmp = new Case();
		Bateau bateau_tmp = new Bateau(), bateau_tmp2 = null;
		int [] tab_nombre_cases_bateaux = bateau_tmp.donne_nombre_de_cases_bateaux(this.grille);
		int nombre_de_bateaux = tab_nombre_cases_bateaux.length;
		this.bateaux = new Bateau[nombre_de_bateaux];
		affichage.afficher_carte_joueur(this.grille, this);
		for (i=0; i<nombre_de_bateaux; i++) {
			ok = false;
			while(!ok) {
				bateau_tmp2 = place_bateau((i+1), tab_nombre_cases_bateaux[i]);
				cases_occupees = utilitaire.cases_occuppees(this);
				if (!case_tmp.contient_case(cases_occupees, bateau_tmp2.cases)) ok=true;
				if (!ok)
					aff("Il y a déjà un bateau placé là");
				bateaux[i] = bateau_tmp2;
			}
			cases_occupees = utilitaire.cases_occuppees(this);
			plateau = utilitaire.construit_plateau(this);
			affichage.afficher_carte_joueur(this.grille, this);
		}
	}

	public int [][] genere_plateau_cases_tentees (Joueur joueur_attaquant) {
		int [][] plateau = joueur_attaquant.construit_plateau_cases_tentees();
		return plateau;
	}

	public void affiche_plateau_attaquant (Joueur joueur_attaquant) {
		Affichage affichage = new Affichage();

		int [][] plateau = genere_plateau_cases_tentees(joueur_attaquant);

		affichage.afficher_carte_attaque_joueur (plateau, joueur_attaquant.numero_du_joueur);
	}

	public boolean tenter_une_case_IA (Joueur joueur_attaque) {
		int etat_case = -1;
		IA ia_tmp = new IA(grille);
		if (carte_a_montrer) affiche_plateau_attaquant(this);
		Case case_tentee = new Case(-1, -1);
		// Vérifie s'il reste des cases à tenter sur le plateau.
		if (cases_a_tenter()) {
			case_tentee = ia_tmp.genere_une_case_aleat(this);
			aff("Joueur "+this.numero_du_joueur+" : ");
			aff("? = "+(char)(('A'+case_tentee.ordonnee-1))+case_tentee.abscisse);
			//aff(case_tentee.aff_case_str());
			etat_case = joueur_attaque.attaquer_une_case(case_tentee);
			ajoute_une_case_tentee(this, case_tentee, etat_case);
			return true;
		}
		else {
			aff("Joueur "+numero_du_joueur+", tenter_une_case : toutes les cases du plateau ont été tentées");
			return false;
		}
	}

	public boolean tenter_une_case (Joueur joueur_attaque) {
		int etat_case = -1;
		int [] tmp;
		IA ia_tmp = new IA(grille);
		boolean case_en_double = false;
		Case case_tentee = new Case(-1, -1);
		if (carte_a_montrer) affiche_plateau_attaquant(this);
		// Vérifie s'il reste des cases à tenter sur le plateau.
		if (cases_a_tenter()) {
			case_en_double = true;
			while (case_en_double) {
				tmp = menu.entre_case(grille, "Joueur "+numero_du_joueur+" : \nEntrer la case à jouer");
				case_tentee = new Case(tmp[0], tmp[1]);
				if (!utilitaire.verifie_case_tentee(this.cases_tentees, cases_tentees_indice, case_tentee)) {
					case_en_double = true;
					aff("Attention, la case "+case_tentee.case_format_ecrit()+" a déjà été tentée.");
					aff("Veuillez entrer une autre case :");
				}
				else case_en_double = false;
			}
			etat_case = joueur_attaque.attaquer_une_case(case_tentee);
			ajoute_une_case_tentee(joueur_attaque, case_tentee, etat_case);
			return true;
		}
		else {
			aff("Joueur "+numero_du_joueur+", tenter_une_case : toutes les cases du plateau ont été tentées");
			return false;
		}
	}

	/**
		Met à jour les bateaux coulés sur le plateau
	**/
	public void met_a_jour_plateau_coule () {
		int i, j;
		int ordonnee;
		int abscisse;

		for (i=0; i<bateaux.length; i++) {
			if (bateaux[i].est_coule()) {
				for (j=0; j<bateaux[i].cases.length; j++) {
					ordonnee = bateaux[i].cases[j].ordonnee-1;
					abscisse = bateaux[i].cases[j].abscisse-1;

					plateau[ordonnee][abscisse].couler();
				}
			}
		}
	}

	public void perd () {
		this.a_perdu = true;
	}

	public boolean a_perdu () {
		int i;

		if (a_perdu) return true;
		for (i=0; i<bateaux.length; i++) {
			//aff("bateaux[i].est_coule() : "+bateaux[i].est_coule());
			if (!bateaux[i].est_coule()) return false;
		}
		perd();
		return true;
	}

	/**
		0 : case non-tentée
		1 : case tentée
	**/
	public int [][] construit_plateau_cases_tentees () {
		int i, j;
		int ordonnee;
		int abscisse;
		int etat;

		Case case_tmp = new Case();

		int [][] plateau = new int[grille.hauteur][grille.largeur];

		// Initialisation du plateau
		for (i=0; i<plateau.length; i++) {
			for (j=0; j<plateau[i].length; j++) {
				plateau[i][j] = -1;
			}
		}

		// On met les cases tentées dans le plateau
		for (i=0; i<cases_tentees_indice; i++) {
			ordonnee = cases_tentees[i].ordonnee-1;
			abscisse = cases_tentees[i].abscisse-1;
			etat = cases_tentees[i].etat;

			plateau[ordonnee][abscisse] = etat;
		}
		return plateau;
	}

	public Case [] liste_des_cases_coulees () {
		int i, j, h;
		int nombre_de_cases = 0;

		Case [] res;
		for (i=0; i<bateaux.length; i++) {
			if (bateaux[i].coule)
				nombre_de_cases+=bateaux[i].nombre_de_cases;
		}
		res = new Case[nombre_de_cases];
		h = 0;
		for (i=0; i<bateaux.length; i++) {
			if (bateaux[i].coule) {
				for (j=0; j<bateaux[i].cases.length; j++) {
					res[h] = bateaux[i].cases[j];
					h++;
				}
			}
		}
		return res;
	}

	/**
		Met à jour les cases coulée dans les cases tentées 
		pour l'affichage de la carte des cases tentées
	**/
	public void met_a_jour_cases_coulees (Joueur joueur_attaque) {
		int i, j;
		Case case_tmp = new Case();

		Case [] cases_coulees = joueur_attaque.liste_des_cases_coulees();
		for (i=0; i<cases_coulees.length; i++) {
			for (j=0; j<cases_tentees_indice; j++) {
				if (case_tmp.compare_case(cases_coulees[i], cases_tentees[j])) {
					cases_tentees[j].couler(); 
					cases_tentees[j].etat = 2;
				}
			}
		}
	}

// ################### Fonctions utilitaires ###################### //

	/**
		Retourne true s'il reste des cases à tenter
		false sinon.
	**/
	public boolean cases_a_tenter () {
		return (cases_tentees_indice<cases_tentees.length);
	}

	public boolean ajoute_une_case_tentee (Joueur joueur_attaque, Case case_tentee, int etat_case) {
		if (etat_case==2)
			met_a_jour_cases_coulees(joueur_attaque);
		if (!cases_a_tenter()) return false;
		else {
			case_tentee.etat = etat_case;
			cases_tentees[cases_tentees_indice++] = case_tentee;
			return true;
		}
	}

	public void affiche_status_bateaux () {
		int i;

		for (i=0; i<bateaux.length; i++) {
			aff("Bateau "+(i+1)+" : ");
			bateaux[i].aff_cases_touchee();
		}
	}

	public void affiche_espaces (int nombre_d_espaces) {
		int i;

		for (i=0; i<nombre_d_espaces; i++) {
			affnn(" ");
		}
	}

	public void affiche_sauts_de_ligne (int nombre_de_lignes) {
		int i;

		for (i=0; i<nombre_de_lignes; i++) {
			affnn("\n");
		}
	}

	public String toString() {
		String res = ""+numero_du_joueur;
		return res;
	}

	public int get_numero_du_joueur () {
		return this.numero_du_joueur;
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1.2 (Jeu finit)/src/Menu.java

import java.util.Scanner;

class Menu {
	Utilitaire utilitaire;
	Case case_1;

	public Menu () {
		this.case_1 = new Case();
		this.utilitaire = new Utilitaire();
	}

	public int menu_principal () {
		int res=-1;
		aff("\n   ******* Menu principal ******* \n");
		while (res!=1 && res!=2 && res!=3) {
			aff("\t1 : Jouer");
			aff("\t2 : Jouer à plus de deux joueurs");
			aff("\t3 : Quitter");
			affnn("\n   ");
			res = entrer_entier("entre 1 et 3");
		}
		return res;
	}

// ###################### Fonctions du jeu ######################## //

// ###******** Fonctions de positionnements des bateaux ********### //

	public int menu_positionnement_bateaux_1 (int numero_du_joueur) {
		int res=-1;	
		aff("\n   ******* Menu joueur 2 ******* \n");
		aff("Le joueur "+numero_du_joueur+" doit :");
		while (res!=1 && res!=2) {
			aff("\t1 : Placer ses bateau soi-même");
			aff("\t2 : Placer ses bateau aléatoirement");
			affnn("\n   ");
			res = entrer_entier("entre 1 et 2");
		}
		return res;
	}

	public int menu_IA_humain (int numero_du_joueur) {
		int res=-1;	
		aff("\n   ******* Menu joueur 1 ******* \n");
		aff("Le joueur "+numero_du_joueur+" est un :");
		while (res!=1 && res!=2) {
			aff("\t1 : Joueur humain");
			aff("\t2 : joueur IA");
			affnn("\n   ");
			res = entrer_entier("entre 1 et 2");
		}
		return res;
	}

	public boolean IA_humain (int numero_du_joueur) {
		int q = menu_IA_humain(numero_du_joueur);
		if (q==1) return false;
		else return true;
	}

	public int entre_nombre_de_joueurs () {
		int res = -1;
		aff("\nEntrer le nombre de joueurs :");
		while (res<2) {
			res = entrer_entier(" suppérieur à ou égal 2");
		}
		return res;
	}

	public int entre_nombre_de_bateaux (int nombre_de_cases_restantes) {
		int res = -1;

		while (res<1 || res>nombre_de_cases_restantes) {
			aff("Veuillez entrer le nombre de bateaux :");
			res = entrer_entier_phrase("inférieur ou égal à "+nombre_de_cases_restantes+" et suppérieur à 0");
		}
		return res;
	}

	public int entre_nombre_de_case_bateau (Grille grille, int numero_du_bateau, 
			int nombre_de_cases_restantes, int nombre_de_bateaux_restants) {
		int res = -1;
		Bateau bateau_tmp = new Bateau();
		int chiffre_a_entrer_inferieur_a = bateau_tmp.taille_max_bateau(grille, 
				nombre_de_cases_restantes-(nombre_de_bateaux_restants-1));
		while (res<1 || res>chiffre_a_entrer_inferieur_a) {
			aff("Entrer le nombre de cases du bateau "+numero_du_bateau+" : ");
			res = entrer_entier_phrase("inférieur ou égal à "+chiffre_a_entrer_inferieur_a+" et suppérieur à 0");
		}
		return res;
	}

	/**
		Donne les bateaux d'un joueur
		Chaque case du tableau int[] 
		contient le nombre du case d'un bateau.
	**/
	public int[] entre_nombre_de_case_bateaux (Grille grille, int nombre_de_cases_restantes) {
		int i;
		int tmp;
		int [] res;
		int nombre_de_cases_restantes_tmp = nombre_de_cases_restantes;
		int nombre_de_bateaux_restants;

		aff("Il vous reste "+nombre_de_cases_restantes+" cases à occuper avec vos bateaux.");
		int nombre_de_bateaux = entre_nombre_de_bateaux(nombre_de_cases_restantes);
		nombre_de_bateaux_restants = nombre_de_bateaux;
		res = new int[nombre_de_bateaux];
		for (i=0; i<nombre_de_bateaux ; i++) {
			tmp = entre_nombre_de_case_bateau(grille, (i+1), nombre_de_cases_restantes_tmp, nombre_de_bateaux_restants);
			res[i] = tmp;
			nombre_de_cases_restantes_tmp-=tmp;
			nombre_de_bateaux_restants--;
		}
		return res;
	}

	/**
		Donne la pemière et la dernière case 
		du bateau.
		Renvoie un int [] :
			int[0] : première case, ordonnée
			int[1] : première case, abscisse
			int[2] : deuxième case, ordonnée
			int[3] : deuxième case, abscisse
	**/
	public int [] donne_cases_bateau (Grille grille, int numero_du_bateau, int nombre_de_cases_bateau) {
		String message = "Entrer la première case du bateau numéro "+numero_du_bateau+" à "+nombre_de_cases_bateau+" case(s) : ";
		int [] case1 = entre_case(grille, message);
		message = "Entrer la dernière case du bateau numéro "+numero_du_bateau+" à "+nombre_de_cases_bateau+" case(s) : ";
		int [] case_fin = entre_case(grille, message);
		int [] res = new int[4];

		res[0] = case1[0];
		res[1] = case1[1];
		res[2] = case_fin[0];
		res[3] = case_fin[1];

		return res;
	}

	public int [] entre_case (Grille grille, String message) {
		int i = 0;
		Scanner sc = new Scanner(System.in);
		String reponse = "";
		affnn(message+"\n? = ");
		while (!case_1.verifie_case_existe(grille, reponse)) {
			if (i>0 && !case_1.verifie_case_existe(grille, reponse))
				affnn("Format de case incorrect\n? = ");
			reponse = sc.nextLine();
			i++;
		}
		return case_1.convertit_case_en_coordonnee(grille, reponse);
	}

// ################### Fonctions utilitaires ###################### //

	public int entrer_entier (String precision) {
		Scanner sc = new Scanner(System.in);
		String res = "";

		affnn("? = ");
		res = sc.nextLine();
		while (!is_integer(res)) {
			aff("Veuillez entrer en entier "+precision+" : ");
			affnn("? = ");
			res = sc.nextLine();
		}
		return Integer.parseInt(res);
	}

	public int entrer_entier_phrase (String precision) {
		Scanner sc = new Scanner(System.in);
		String res = "";

		aff("Veuillez entrer en entier "+precision+" : ");
		affnn("? = ");
		res = sc.nextLine();
		while (!is_integer(res)) {
			aff("Veuillez entrer en entier "+precision+" : ");
			affnn("? = ");
			res = sc.nextLine();
		}
		return Integer.parseInt(res);
	}

	public boolean is_integer (String s0) {
		try {
			int n1 = Integer.parseInt(s0);
			return true;
		}
		catch (Exception e) {
			return false;
		}
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1.2 (Jeu finit)/src/Test.java

import java.util.Arrays;

class Test {
	IA ia;
	public Test () {
		//int i;
		//ia = new IA();
		//Utilitaire ut = new Utilitaire();

		/*int [] tmp = {2, 4, 1};

		Arrays.sort(tmp);

		for (i=0; i<tmp.length; i++) {
			aff("tmp["+i+"] = "+tmp[i]);
		}
		int taille_du_bateau = 2;
		int [] tab = {0, 0, 0, 0, 0 };
		ia.scanne_ligne_colonne (tab, taille_du_bateau);
		aff("Case = "+ut.convertit_coordonnees_str(4, 4));
		int [] test = new int[0];
		aff("test.length = "+test.length);
		aff("test[0] = "+test[0]);
		int [] tab = {1, 2};
		aff("tab = "+tab[0].toString());*/
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}

	public static void main (String [] args) {
		Test test = new Test();
	}
}

# ./1.2 (Jeu finit)/src/Utilitaire.java

class Utilitaire {

	public Utilitaire() {}

//################ Fonctions utilitaires du jeu ################//

	public boolean tmp () {
		return true;
	}

	public boolean compare_coordonneee (int ordonnee_source, int abscisse_source, int ordonnee_but, int abscisse_but) {
		return (ordonnee_source==ordonnee_but &&
			abscisse_source==abscisse_but);
	}

	/**
		Un bateau peut être soit horizontal ou vertical soit oblique.
		Cas :

		case_fin est égale à case_1
		case_fin à gauche de case_1
		case_fin à droite de case_1
		case_fin en haut de case_1
		case_fin en bas de case_1		
	**/
	public boolean verifie_placement_bateau (int [] case_1, int [] case_fin, int nombre_de_cases) {
		int tmp = 0;

		if (case_1[0]==case_fin[0] && case_1[1]==case_fin[1]) {
			if (nombre_de_cases==1) return true;
			else return false;
		}
		//Horizontal
		if (case_1[0]==case_fin[0]) {
			//case_fin à gauche de case_1
			if (case_fin[1]<case_1[1]) {
				tmp = case_1[1]-case_fin[1];
				if (tmp==nombre_de_cases && tmp>0) return true;
				else return false;
			}
			//case_fin à droite de case_1
			if (case_fin[1]>case_1[1]) {
				tmp = case_fin[1]-case_1[1];
				if (tmp==nombre_de_cases && tmp>0) return true;
				else return false;
			}
		}
		//Vertical
		if (case_1[1]==case_fin[1]) {
			//case_fin en haut de case_1
			if (case_fin[0]<case_1[0]) {
				tmp = case_1[1]-case_fin[1];
				if (tmp==nombre_de_cases && tmp>0) return true;
				else return false;
			}
			//case_fin en base de case_1
			if (case_fin[0]>case_1[0]) {
				tmp = case_fin[1]-case_1[1];
				if (tmp==nombre_de_cases && tmp>0) return true;
				else return false;
			}
		}
		return false;
	}

	/**
		Prend un tableau de 4 int tel que :
		t[0] = case_1_ordonnee
		t[1] = case_1_abscisse
		t[2] = case_fin_ordonnee
		t[3] = case_fin_abscisse

		renvoie l'ensemble des cases du bateau.
	**/
	public Case [] donne_cases_bateau (int [] cases, int nombre_de_cases) {
		int i;
		int [] case_1 = {cases[0], cases[1]};
		int [] case_fin = {cases[2], cases[3]};;
		Case [] res = new Case[nombre_de_cases];

		if (case_1[0]==case_fin[0] && case_1[1]==case_fin[1]) {
			res[0] = new Case(cases[0], cases[1]);
		}
		//Horizontal
		if (case_1[0]==case_fin[0]) {
			//case_fin à gauche de case_1
			if (case_fin[1]<case_1[1]) {
				for (i=0; i<nombre_de_cases; i++) {
					res[i] = new Case(case_1[0], case_1[1]-i);
				}
			}
			//case_fin à droite de case_1
			if (case_fin[1]>case_1[1]) {
				for (i=0; i<nombre_de_cases; i++) {
					res[i] = new Case(case_1[0], case_1[1]+i);
				}
			}
		}
		//Vertical
		if (case_1[1]==case_fin[1]) {
			//case_fin en haut de case_1
			if (case_fin[0]<case_1[0]) {
				for (i=0; i<nombre_de_cases; i++) {
					res[i] = new Case(case_1[0]-i, case_1[1]);
				}
			}
			//case_fin en bas de case_1
			if (case_fin[0]>case_1[0]) {
				for (i=0; i<nombre_de_cases; i++) {
					res[i] = new Case(case_1[0]+i, case_1[1]);
				}
			}
		}
		return res;
	}

	/**
		Remplit un tableau de Case[] des cases 
		occupées pour rendre accessible un Bateau, 
		une Case et un Joueur à partir d'un même objet.
		
	**/
	public Case [] cases_occuppees (Joueur joueur) {
		int i, j, h;
		int nombre_de_bateaux_initialises = 0;
		int ordonnee, abscisse;
		int nombre_total_de_cases = 0;
		Case [] res;
		Bateau [] bateaux = joueur.bateaux;
		for (i=0; i<bateaux.length; i++) {
			if (bateaux[i]!=null) {
				nombre_de_bateaux_initialises+=1;
			}
		}

		/**
			Compte le nombre total de cases.
		**/
		for (i=0; i<nombre_de_bateaux_initialises; i++) {
			if (bateaux[i]!=null)
				nombre_total_de_cases+=bateaux[i].cases.length;
		}
		res = new Case[nombre_total_de_cases];
		h = 0;
		for (i=0; i<nombre_de_bateaux_initialises; i++) {
			if (bateaux[i]!=null) {
				for (j=0; j<bateaux[i].cases.length; j++) {
					if (bateaux[i]!=null) {
						ordonnee = bateaux[i].cases[j].ordonnee;
						abscisse = bateaux[i].cases[j].abscisse;
						res[h] = new Case(joueur, bateaux[i], 
							(i+1), ordonnee, abscisse);
					h++;
					}
				}
			}
		}
		return res;		
	}

	/**
		Si trouve la case recherchée, la retourne,
		sinon retourne null.
	**/
	public Case cherche_case (Case [] cases, Case case_1) {
		int i;
		Case res = null;

		for (i=0; i<cases.length; i++) {
			if ((new Case()).compare_case (cases[i], case_1)) return cases[i];
		}
		return res;
	}

	/**
		Construit un plateau pour chaque joueur
		en fonction de ses bateaux.
	**/
	public Case [][] construit_plateau (Joueur joueur) {
		int i, j;
		Case case_tmp, case_tmp2;

		Case [][] plateau = new Case[joueur.grille.hauteur][joueur.grille.largeur];

		for (i=0; i<plateau.length; i++) {
			for (j=0; j<plateau[i].length; j++) {
				case_tmp = new Case((i+1), (j+1));
				case_tmp2 = cherche_case(joueur.cases_occupees, case_tmp);
				if (case_tmp2!=null)
					plateau[i][j] = case_tmp2;
				else plateau[i][j] = case_tmp;
			}
		}
		return plateau;
	}

	/**
		Recherche le premier joueur du tableau 
		qui n'a pas perdu. Renvoie son emplacement 
		dans le tableau.
	**/
	public int recherche_gagnant (Joueur [] joueurs) {
		int i;

		for (i=0; i<joueurs.length; i++) {
			if (!joueurs[i].a_perdu()) return i;
		}
		return -1;
	}

	/**
		Retourne false si la case tentée a déjà été tentée,
		true sinon.
	**/
	public boolean verifie_case_tentee (Case [] cases_tentees, int cases_tentees_indice, Case case_tentee) {
		int i;
		Case case_tmp = new Case();

		for (i=0; i<cases_tentees_indice; i++) {
			if (case_tmp.compare_case(cases_tentees[i], case_tentee)) return false;
		}
		return true;
	}

	public String convertit_coordonnees_str (int ordonnee, int abscisse) {
		return ""+(char)('A'+ordonnee-1)+abscisse;
	}

	/**
		-1 : rien
		 0 : dans l'eau
		 1 : touché
		 2 : coulé
	**/
	public void afficher_evenement_coup (int tmp) {
		String res = "";

		if (tmp==0) res = "Dans l'eau !";
		if (tmp==1) res = "Touché !";
		if (tmp==2) res = "Coulé !";

		aff("\n\t\t"+res+"\n");
	}

//################### Fonctions utilitaires ####################//

	public void aff_tab (String nom, Case [] cases) {
		aff_tab(nom, cases, cases.length);
	}

	public void aff_tab (String nom, Case [] cases, int cases_tentees_indice) {
		int i;
		int cases_tentees_indice_tmp = Math.min(cases_tentees_indice, cases.length);

		for (i=0; i<cases_tentees_indice_tmp; i++) {
			if (cases[i]==null)
				aff(nom+"["+i+"] = null");
			else aff(nom+"["+i+"] = \n"+cases[i].aff_case_str());
		}
	}

	public void aff_tab (String nom, int [] tab) {
		int i;
		for (i=0; i<tab.length; i++) {
			aff(nom+"["+i+"] = "+tab[i]);
		}
	}

	public boolean is_integer (String s0) {
		try {
			int n1 = Integer.parseInt(s0);
			return true;
		}
		catch (Exception e) {
			return false;
		}
	}

	public int randInt (int min, int max) {
		int res = (int)(Math.random()*max)+min;
		if (res>max) res = max;
		if (res<min) res = min;

		return res;
	}

	public int formate_int (int min, int max, int tmp) {
		int res = tmp;
		if (res<min)
			res = min;
		if (res>max)
			res = max;
		return res;
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1.4 (Jeu finit (amÃ©liorÃ©), IA - en cours)/src/Affichage.java

class Affichage {
	int nombre_d_espaces;

	public Affichage () {
		this.nombre_d_espaces = 5;
	}

	public void afficher_carte_attaque_joueur (int [][] plateau, int numero_du_joueur) {
		char charactere = 'A';
		String tmp_str_1="";
		int i, j, h;
		int tmp_int_1 = 1;
		int hauteur = plateau.length;
		int largeur = plateau[0].length;

		aff("\nLégende : \n\n  0 : case pas encore attaquée\n  X : Dans l'eau\n  1 : Touché\n  2 : Coulé");
		aff("\nTableau d'attaque du joueur "+numero_du_joueur+" : \n");

		affiche_espaces(nombre_d_espaces+1);
		for (i=0; i<largeur; i++) {
			affnn(""+(i+1));
			if (i>(9-1))
				affiche_espaces(nombre_d_espaces-1);
			else
				affiche_espaces(nombre_d_espaces);
		}
		affiche_sauts_de_ligne(1);

		affiche_sauts_de_ligne(1);
		for (i=0; i<hauteur; i++) {
			affnn(""+(charactere++));
			affiche_espaces(nombre_d_espaces);
			for (j=0; j<largeur; j++) {
				if (plateau[i][j]==-1)
					tmp_str_1 = "0";
				else if (plateau[i][j]==0)
					tmp_str_1 = "X";
				else 
					tmp_str_1 = ""+plateau[i][j];
				tmp_int_1 = 1;
				affnn(tmp_str_1);
				affiche_espaces(nombre_d_espaces-(tmp_int_1-1));
			}
			affiche_sauts_de_ligne(2);
		}
	}

	public void afficher_carte_joueur (Grille grille, Joueur joueur) {
		if (!joueur.carte_a_montrer) return;
		char c = 'A';
		String tmp_str_1="";
		int i, j, h;
		int tmp_int_1 = 1;
		int numero_du_joueur = joueur.get_numero_du_joueur();
		Case [][] plateau = joueur.plateau;
		int hauteur = grille.hauteur;
		int largeur = grille.largeur;

		aff("\nTableau du joueur "+numero_du_joueur+" : \n");

		affiche_espaces(nombre_d_espaces+1);
		for (i=0; i<largeur; i++) {
			affnn(""+(i+1));
			if (i>(9-1))
				affiche_espaces(nombre_d_espaces-1);
			else
				affiche_espaces(nombre_d_espaces);
		}
		affiche_sauts_de_ligne(1);

		affiche_sauts_de_ligne(1);
		for (i=0; i<hauteur; i++) {
			affnn(""+(c++));
			affiche_espaces(nombre_d_espaces);
			for (j=0; j<largeur; j++) {
				if (plateau!=null) {
					tmp_str_1 = plateau[i][j].toString();
					tmp_int_1 = tmp_str_1.length();
					affnn(tmp_str_1);
				}
				else affnn("0");
				affiche_espaces(nombre_d_espaces-(tmp_int_1-1));
			}
			affiche_sauts_de_ligne(2);
		}
	}


// ################### Fonctions utilitaires ###################### //

	public void affiche_espaces (int nombre_d_espaces) {
		int i;

		for (i=0; i<nombre_d_espaces; i++) {
			affnn(" ");
		}
	}

	public void affiche_sauts_de_ligne (int nombre_de_lignes) {
		int i;

		for (i=0; i<nombre_de_lignes; i++) {
			affnn("\n");
		}
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1.4 (Jeu finit (amÃ©liorÃ©), IA - en cours)/src/Bateau.java

class Bateau {
	Menu menu;
	int nombre_de_cases;
	boolean touche;
	boolean coule;

	public Case [] cases;

	public Bateau() {
		menu = new Menu();
	}

	/**
		Cases : 
			Liste des cases du plateau 
			sur lesquel est le bateau.
	**/
	public Bateau (Case [] cases) {
		menu = new Menu();
		this.nombre_de_cases = cases.length;
		this.cases = cases;
		touche = false;
		coule = false;
	}

// ######## Fonctions utilitaires pour les bateaux ######### //

// ###************** Placement des bateaux **************### //

	/**
		Renvoie le nombre de cases max.

		Soit n le nombre de joueurs
		et m le nombre de cases total
		de la grille.

		Calcul : res = (1/(n+1))*m
	**/
	public int nombre_de_place_de_bateau_max (Grille grille) {
		int hauteur = grille.hauteur;
		int largeur = grille.largeur;

		int nombre_de_cases_total = hauteur*largeur;
		int max_autorise = (int)((3.0/5.0)*nombre_de_cases_total);

		return max_autorise;
	}

	/**
		Donne la taille max d'un bateau
		en fonction de la hauteur et 
		de la largeur de la grille uniquement.
	**/
	public int taille_max_bateau (Grille grille, int proposition) {
		int hauteur = grille.hauteur;
		int largeur = grille.largeur;
		int max_hauteur_largeur = Math.min(hauteur, largeur);

		if (proposition>max_hauteur_largeur) return max_hauteur_largeur;
		else return proposition;
	}

	/**
		Donne les bateaux d'un joueur
		Chaque case du tableau int[] 
		contient le nombre du case d'un bateau.
	**/
	public int [] donne_nombre_de_cases_bateaux (Grille grille) {
		int nombre_de_place_de_bateau_max = nombre_de_place_de_bateau_max(grille);

		int [] res = menu.entre_nombre_de_case_bateaux(grille, nombre_de_place_de_bateau_max);		

		return res;
	}

// ################ Fonctions utilitaires du jeu ################ //

	public boolean attaque (Case case_a_attaquer) {
		int i;
		Case case_tmp = new Case();
		boolean est_coule;
		if (!case_a_attaquer.contient_case(this.cases, 
						case_a_attaquer)) {
			return false;
		}
		for (i=0; i<cases.length; i++) {
			if (case_tmp.compare_case(cases[i], case_a_attaquer)) {
				cases[i].attaquer();
			}
		}
		this.coule = verifie_coule();		

		return true;
	}

	public boolean verifie_coule () {
		int i;

		for (i=0; i<cases.length; i++) {
			if (!cases[i].est_attaquee()) {
				return false;
			}
		}
		for (i=0; i<cases.length; i++) {
			cases[i].couler();
		}
		return true;
	}

	public boolean est_coule () {
		return coule;
	}

// ################### Fonctions utilitaires ###################### //

	public void aff_cases () {
		int i;

		for (i=0; i<cases.length; i++) {
			aff("Case "+(i+1)+" : \n"+cases[i].aff_case_str());
		}
	}

	public void aff_cases_touchee () {
		int i;

		for (i=0; i<cases.length; i++) {
			if (cases[i].est_attaquee())
				aff("cases["+(i+1)+"] est attaquée");
			else 
				aff("cases["+(i+1)+"] n'est pas attaquée");
		}
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}

}

# ./1.4 (Jeu finit (amÃ©liorÃ©), IA - en cours)/src/Case.java

class Case {
	public int ordonnee;
	public int abscisse;
	public Joueur joueur;
	public Bateau bateau;
	public int numero_du_bateau;

	public boolean attaquee;
	public boolean coule;

	/**
		Pour le tableau d'attaque :
		0 : tans l'eau
		1 : touché
		2 : coulé
	**/
	public int etat;

	public Case() {}

	public Case (int ordonnee, int abscisse) {
		constructeur(ordonnee, abscisse);
		this.etat = -1;
	}

	public Case (Joueur joueur, Bateau bateau, int numero_du_bateau, 
						int ordonnee, int abscisse) {
		this.joueur = joueur;
		this.bateau = bateau;
		this.numero_du_bateau = numero_du_bateau;
		constructeur(ordonnee, abscisse);
		this.etat = -1;
	}

	public Case (int ordonnee, int abscisse, int etat) {
		constructeur(ordonnee, abscisse);
		this.etat = etat;
	}

	public void constructeur (int ordonnee, int abscisse) {
		this.ordonnee = ordonnee;
		this.abscisse = abscisse;
		this.attaquee = false;
		this.coule = false;
	}

// ################ Fonctions utilitaires du jeu ################ //

	public boolean est_attaquee() {
		return attaquee;
	}

	public boolean est_coulee() {
		return coule;
	}

	public void attaquer () {
		attaquee = true;
	}

	public void couler () {
		coule = true;
	}

	/**
		Format correct : A5.
	**/
	public boolean verifie_format_case (String s0, int hauteur) {
		char tmp, tmp2;
		if (s0==null) return false;
		if (s0.length()==2) {
			tmp = s0.charAt(0);
			if (tmp>='A' && tmp<=('A'+(hauteur-1))) {
				tmp2 = s0.charAt(1);
				if (is_integer(""+tmp2)) return true;
				else return false;
			} else return false;
		} else return false;
	}

	/**
		On donne des coordonnées type A5
		et la fonction donne 1, 5 pour A5
	**/
	public int [] convertit_case_en_coordonnee (Grille grille, String s0) {
		int [] res = new int[2];
		char c='A';
		int ordonnee;
		int abscisse;

		if (verifie_case_existe(grille, s0)) {
			ordonnee = (int)(s0.charAt(0)-(int)('A')+1);
			abscisse = (int)(s0.charAt(1)-(int)('0'));
			res[0] = ordonnee;
			res[1] = abscisse;
		}
		else {
			aff("convertit_case_en_coordonnee : Format incorrect");
			return null;
		}

		return res;
	}


	public boolean verifie_case_existe (Grille grille, String case_tmp) {
		if (case_tmp==null) return false;
		if (case_tmp.isEmpty()) return false;
		if (case_tmp.length()!=2) return false;
		if (!verifie_format_case(case_tmp, grille.hauteur)) return false;
		int abscisse = (int)(case_tmp.charAt(1)-'1'+1);
		if (abscisse<1 || abscisse>grille.largeur) return false;
		return true;
	}

	/**
		Prend la première case et la dernière case
		et retourne un tableau de cases contenant
		toutes les cases du bateau.
	**/
	public void convertit_case (Case case_1, Case case_fin) {
		
	}

	/**
		Renvoie true si l'une des cases de tab2 est dans tab1.

	**/
	public boolean contient_case (Case [] tab1, Case[] tab2) {
		int i, j;
		Case case_tmp = new Case();

		for (i=0; i<tab1.length; i++) {
			for (j=0; j<tab2.length; j++) {
				if (case_tmp.compare_case(tab1[i], tab2[j])) return true;
			}
		}
		return false;
	}

// ################### Fonctions utilitaires #################### //

	public boolean compare_case (Case case_1, Case case_2) {
		return (case_1.ordonnee==case_2.ordonnee &&
			case_1.abscisse==case_2.abscisse);
	}

	public boolean contient_case (Case [] cases, Case case_a_comparer) {
		int i;

		for (i=0; i<cases.length; i++) {
			if (compare_case(cases[i], 
				case_a_comparer)) return true;
		}
		return false;
	}

	public boolean is_integer (String s0) {
		try {
			int n1 = Integer.parseInt(s0);
			return true;
		}
		catch (Exception e) {
			return false;
		}
	}

	public String aff_case_str () {
		String res="";
		res+="Ordonnee = "+ordonnee+"\n";
		res+="Abscisse = "+abscisse+"\n";
		return res;
	}

	/**
		Donne les coordonnées de la case en format type : A5
	**/
	public String case_format_ecrit() {
		return (new Utilitaire()).convertit_coordonnees_str(ordonnee, abscisse);
	}

	public String toString() {
		String res = "";
		if (joueur!=null) {
			res = "J"+joueur.toString()+"B"+this.numero_du_bateau;
			if (attaquee && !coule) {
				res = "T"+res;
			}
			if (attaquee && coule) {
				res = "C"+res;
			}
		}
		else {
			if (attaquee) {
				res = "X  ";
			}
			else res = "0  ";
		}
		return res;
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}

}

# ./1.4 (Jeu finit (amÃ©liorÃ©), IA - en cours)/src/Grille.java


class Grille {
	public int hauteur;
	public int largeur;

	public Grille (int hauteur, int largeur) {
		this.hauteur = hauteur;
		this.largeur = largeur;
	}

// ################### Fonctions utilitaires ###################### //

	public String toString () {
		String res = "";
		res+="Hauteur = "+hauteur+"\n";
		res+="Largeur = "+largeur+"\n";
		return res;
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1.4 (Jeu finit (amÃ©liorÃ©), IA - en cours)/src/IA.java

import java.util.Arrays;

class IA {
	public int [][] plateau;
	Utilitaire utilitaire;
	Grille grille;

	public IA () {
		constructeur();
	}

	public IA (Grille grille) {
		this.grille = grille;
		constructeur();
	}

	public void constructeur() {
		utilitaire = new Utilitaire();
	}

	public Joueur place_bateaux_IA (Grille grille, int numero_du_joueur, boolean IA_humain, boolean carte_a_montrer) {
		int i;
		int tmp = 0;

		int nombre_de_gros_bateaux = 0;
		int tentative = 0;
		int tentative_2 = 0;
		Joueur res = null;
		Bateau bateau_tmp = new Bateau();
		int hauteur = grille.hauteur;
		int largeur = grille.largeur;
		int [] nombre_de_cases_bateaux;

		int nombre_de_bateaux = 0;

		int nombre_de_cases_max = bateau_tmp.nombre_de_place_de_bateau_max(grille);
		int min_hauteur_largeur = Math.min(hauteur, largeur);
		int nombre_cases_bateau_max;
		
		int nombre_de_cases_restantes = nombre_de_cases_max;
		while (nombre_de_cases_restantes>0) {
			nombre_de_cases_restantes-=min_hauteur_largeur;
			nombre_de_gros_bateaux++;
		}
		nombre_de_bateaux+=nombre_de_gros_bateaux;
		if ((-nombre_de_cases_restantes)>0) nombre_de_bateaux++;
		if (nombre_de_bateaux<1) nombre_de_bateaux = 1;
		nombre_de_cases_bateaux = new int[nombre_de_bateaux];

		for (i=0; i<nombre_de_bateaux; i++) {
			nombre_de_cases_restantes = nombre_de_cases_max;
			if (nombre_de_gros_bateaux>0) {
				nombre_cases_bateau_max = Math.min(nombre_de_cases_restantes, min_hauteur_largeur);
				//tmp = randInt(1, nombre_cases_bateau_max);
				//tmp = nombre_cases_bateau_max;
				tmp = randInt((int)((4.0/10)*nombre_cases_bateau_max), nombre_cases_bateau_max);
				if (tmp<1) tmp = 1;
				nombre_de_cases_bateaux[i] = tmp;
				nombre_de_cases_restantes-=tmp;
				nombre_de_gros_bateaux--;
			}
			else nombre_de_cases_bateaux[i] = Math.min(nombre_de_cases_restantes, min_hauteur_largeur);
			if (nombre_de_cases_bateaux[i]<1) nombre_de_cases_bateaux[i] = 1;
		}

		this.plateau = cree_plateau_tmp(grille);
		Bateau [] bateaux = new Bateau[nombre_de_bateaux];
		for (i=0; i<nombre_de_bateaux; i++) {
			bateaux[i] = null;
			tentative_2 = 0;
			while (bateaux[i] == null && tentative_2<5) {
				tentative = 0;
				while (bateaux[i] == null && tentative<5) {
					bateaux[i] = place_un_bateau(grille, nombre_de_cases_bateaux[i]);
					tentative++;
				}
				if (bateaux[i] == null) {
					aff("Bateaux numéro "+(i+1)+", "+tentative+" tentative(s) avec "+nombre_de_cases_bateaux[i]+" case(s).");
					nombre_cases_bateau_max = Math.min(nombre_de_cases_bateaux[i], min_hauteur_largeur);
					nombre_de_cases_bateaux[i] = randInt(1, nombre_cases_bateau_max);
					aff("Nouvel essai avec "+nombre_de_cases_bateaux[i]+" case(s).");
				}
				tentative_2++;
			}
			if (bateaux[i] == null) {
				aff("Bateaux numéro "+(i+1)+" dernier essai avec une seule case.");
				tentative = 0;
				nombre_de_cases_bateaux[i] = 1;
				while (bateaux[i] == null && tentative<5) {
					bateaux[i] = place_un_bateau(grille, nombre_de_cases_bateaux[i]);
					tentative++;
				}
			}
			if (bateaux[i] == null) {
				aff("Bateaux numéro "+(i+1)+" : échec avec une seule case.");
			}
			//afficher_plateau();
		}
		bateaux = adapte_le_nombre_de_bateaux(bateaux);
		res = new Joueur(numero_du_joueur, grille, bateaux, IA_humain, carte_a_montrer);

		return res;
	}

	/**
		Si certains bateaux sont nuls dans bateaux[], retourne un 
		nouveau tableau de Bateau sans les Bateau nuls.
	**/
	public Bateau [] adapte_le_nombre_de_bateaux (Bateau [] bateaux) {
		int i, h;
		Bateau [] bateaux_res;
		int nombre_de_bateaux_calcule = 0;

		for (i=0; i<bateaux.length; i++) {
			if (bateaux[i]!=null)
				nombre_de_bateaux_calcule++;
		}
		bateaux_res = new Bateau[nombre_de_bateaux_calcule];
		h = 0;
		for (i=0; i<bateaux.length; i++) {
			if (bateaux[i]!=null) {
				bateaux_res[h++] = bateaux[i];
			}
		}
		return bateaux_res;		
	}

	public boolean vertical_horizontal () {
		int tmp = randInt(0, 100);
		return (tmp<50);
	}

	public Bateau place_un_bateau (Grille grille, int taille_du_bateau) {
		boolean vertical_horizontal = vertical_horizontal ();
		return place_un_bateau_aux(grille, taille_du_bateau, vertical_horizontal);
	}

	/**
		Lorsqu'une case est touché par l'IA, elle essaie de coule le bateau entier si possible.
	**/
	public Case joue_coup_IA_avancee_2 () {
		return null;
	}

	/**
		vertical_horizontal :
			True : Vertical
			False : Horizontal
	**/
	public Bateau place_un_bateau_aux (Grille grille, int taille_du_bateau, boolean vertical_horizontal) {
		int i, j;

		Bateau res = null;
		int hauteur = grille.hauteur;
		int largeur = grille.largeur;
		int tmp2;
		Case case_tmp;
		Case [] cases_disponibles;
		Case [] cases = new Case[taille_du_bateau];

		cases_disponibles = cases_disponibles(vertical_horizontal, taille_du_bateau);
		if (cases_disponibles==null) {
			vertical_horizontal = inverse_bool(vertical_horizontal);
			cases_disponibles = cases_disponibles(vertical_horizontal, taille_du_bateau);
		}
		if (cases_disponibles==null) {
			//aff("IA - Place_un_bateau : Plus de cases disponibles");
			return null;
		}
		tmp2 = randInt(0, cases_disponibles.length-1);
		case_tmp = cases_disponibles[tmp2];
		int [] tmp3 = {case_tmp.ordonnee, case_tmp.abscisse};
		ajoute_un_bateau(tmp3, taille_du_bateau, vertical_horizontal);
		//afficher_plateau();
		case_tmp.abscisse+=1;
		case_tmp.ordonnee+=1;

		// Vertical
		if (vertical_horizontal) {
			j = 0;
			for (i=case_tmp.ordonnee; i<case_tmp.ordonnee+taille_du_bateau; i++) {
				cases[j++] = new Case(i, case_tmp.abscisse);
			}
		}
		// Horizontal
		else {
			j = 0;
			for (i=case_tmp.abscisse; i<case_tmp.abscisse+taille_du_bateau; i++) {
				cases[j++] = new Case(case_tmp.ordonnee, i);
			}
		}
		res = new Bateau(cases);

		return res;
	}

	public int [][] cree_plateau_tmp (Grille grille) {
		int i, j;
		int hauteur = grille.hauteur;
		int largeur = grille.largeur;
		
		int [][] tab = new int[hauteur][largeur];
		for (i=0; i<hauteur; i++) {
			for (j=0; j<largeur; j++) {
				tab[i][j] = 0;
			}
		}
		return tab;		
	}

	public void ajoute_un_bateau (int [] tab, int taille_bateau, boolean vertical_horizontal) {
		ajoute_un_bateau_aux (tab, taille_bateau, vertical_horizontal, true);
	}


	public void ajoute_un_bateau_aux (int [] tab, int taille_bateau, boolean vertical_horizontal, boolean distance_autour) {
		int i, j;

		int ordonnee = tab[0];
		int abscisse = tab[1];

		// Vertical
		if (vertical_horizontal) {
			for (i=ordonnee; i<ordonnee+taille_bateau; i++) {
				this.plateau[i][abscisse] = 1;
			}
			if (distance_autour) {
				if (ordonnee-1>=0)
					this.plateau[ordonnee-1][abscisse] = 1;
				if (ordonnee+taille_bateau<this.plateau.length)
					this.plateau[ordonnee+taille_bateau][abscisse] = 1;
				if (abscisse-1>=0) {
					for (i=ordonnee; i<ordonnee+taille_bateau; i++) {
						this.plateau[i][abscisse-1] = 1;
					}
				}
				if (abscisse+1<this.plateau[0].length) {
					for (i=ordonnee; i<ordonnee+taille_bateau; i++) {
						this.plateau[i][abscisse+1] = 1;
					}
				}
			}
		}
		// Horizontal
		else {
			for (i=abscisse; i<abscisse+taille_bateau; i++) {
				this.plateau[ordonnee][i] = 1;
			}
			if (distance_autour) {
				if (abscisse-1>=0)
					this.plateau[ordonnee][abscisse-1] = 1;
				if (abscisse+taille_bateau<this.plateau[0].length)
					this.plateau[ordonnee][abscisse+taille_bateau] = 1;
				if (ordonnee-1>=0) {
					for (i=abscisse; i<abscisse+taille_bateau; i++) {
						this.plateau[ordonnee-1][i] = 1;
					}
				}
				if (ordonnee+1<this.plateau.length) {
					for (i=abscisse; i<abscisse+taille_bateau; i++) {
						this.plateau[ordonnee+1][i] = 1;
					}
				}
			}
		}
	}

	public Case [] cases_disponibles (boolean vertical_horizontal, int taille_du_bateau) {
		int i, j, h;
		int tmp;
		int hauteur;
		int largeur = 0;
		boolean sature = false;
		int nombre_de_cases = 0;
		Case [] cases_disponibles_res;

		int [][] cases_disponibles = 
			cases_disponibles_aux_1(vertical_horizontal, taille_du_bateau);
		tmp = 0;
		for (i = 0; i<cases_disponibles.length; i++) {
			if (cases_disponibles[i]!=null)	{
				tmp++;
				largeur = cases_disponibles[i].length;
			}
		}
		if (tmp==0) {
			//aff("IA - cases_disponibles : plus de cases disponibles.");
			//aff("Détails : \n\tvertical_horizontal = "+vertical_horizontal);
			return null;
		}
		hauteur = cases_disponibles.length;
		nombre_de_cases = 0;
		for (i = 0; i<cases_disponibles.length; i++) {
			for (j=0; j<largeur; j++) {
				if (cases_disponibles[i]!=null)	nombre_de_cases++;
			}
		}
		cases_disponibles_res = new Case[nombre_de_cases];
		h = 0;
		for (i=0; i<hauteur; i++) {
			for (j=0; j<largeur; j++) {
				if (cases_disponibles[i]!=null) {
					// Vertical
					if (vertical_horizontal) {
						cases_disponibles_res[h] = new Case(j, i);
					}
					// Horizontal
					else {
						cases_disponibles_res[h] = new Case(i, j);
					}
					h++;
				}
			}
		}
		return cases_disponibles_res;
	}

	public int [][] cases_disponibles_aux_1 (boolean vertical_horizontal, int taille_du_bateau) {
		int i, j;
		int [] cases_disponibles_tmp;
		int hauteur = this.plateau.length;
		int largeur = this.plateau[0].length;
		int [] ligne_colonne;
		int [][] cases_disponibles;

		// Vertical
		if (vertical_horizontal) {
			ligne_colonne = new int[hauteur];
			cases_disponibles = new int[largeur][];
			for (i=0; i<largeur; i++) {
				for (j=0; j<hauteur; j++) {
					ligne_colonne[j] = this.plateau[j][i];
				}
				cases_disponibles_tmp = scanne_ligne_colonne(ligne_colonne, taille_du_bateau);
				cases_disponibles[i] = cases_disponibles_tmp;
			}
		}
		// Horizontal
		else {
			ligne_colonne = new int[largeur];
			cases_disponibles = new int[hauteur][];
			for (i=0; i<hauteur; i++) {
				for (j=0; j<largeur; j++) {
					ligne_colonne[j] = this.plateau[i][j];
				}
				cases_disponibles_tmp = scanne_ligne_colonne(ligne_colonne, taille_du_bateau);
				cases_disponibles[i] = cases_disponibles_tmp;
			}
		}
		return cases_disponibles;
	}

	public int [] scanne_ligne_colonne (int [] tab, int taille_du_bateau) {
		int i, j, h;
		boolean ok;
		int nombre_de_cases_possibles = 0;
		int [] cases_possibles = null;
		int taille_du_tableau = tab.length;

		for (i=0; i<taille_du_tableau; i++) {
			ok = true;
			if (i+taille_du_bateau<=taille_du_tableau) {
				for (j=i; j<i+taille_du_bateau; j++) {
					if (j<taille_du_tableau) {
						if (tab[j]==1) ok = false;
					}
				}
			}
			else ok = false;
			if (ok) nombre_de_cases_possibles++;
		}
		cases_possibles = new int[nombre_de_cases_possibles];
		h = 0;
		for (i=0; i<taille_du_tableau; i++) {
			ok = true;
			if (i+taille_du_bateau<=taille_du_tableau) {
				for (j=i; j<i+taille_du_bateau; j++) {
					if (j<taille_du_tableau) {
						if (tab[j]==1) ok = false;
					}
				}
			}
			else ok = false;
			if (ok) {
				cases_possibles[h] = i;
				h++;
			}
		}
		if (nombre_de_cases_possibles==0) {
			//aff("IA - scanne_ligne_colonne : aucune case possible : ");
			//aff("Détails : \n\ttaille_du_bateau = "+taille_du_bateau);
			//aff_tab(tab, "tab");
			return null;
		}
		else return cases_possibles;
	}

	public Case [] cases_occupees () {
		int i, j, h;

		Case [] res = null;
		int taille_res = 0;

		for (i=0; i<this.plateau.length; i++) {
			for (j=0; j<this.plateau[i].length; j++) {
				if (this.plateau[i][j]==1) taille_res++;
			}
		}
		res = new Case[taille_res];
		h = 0;
		for (i=0; i<this.plateau.length; i++) {
			for (j=0; j<this.plateau[i].length; j++) {
				if (this.plateau[i][j]==1) res[h] = new Case(i, j);
				h++;
			}
		}
		if (taille_res==0) return null;
		else return res;
	}

	public boolean joueur_un_coup (Joueur joueur_attaquant, Joueur joueur_attaque) {
		return joueur_attaquant.tenter_une_case_IA(joueur_attaque);
	}

	public boolean ligne_cases_possibles (int [] tab) {
		int i;

		for (i=0; i<tab.length; i++) {
			if (tab[i]!=0) return true;
		}
		return false;
	}

	public int [] ligne_cases_possibles_liste (int [] tab) {
		int i, j;
		int taille_res = 0;
		int [] res;

		for (i=0; i<tab.length; i++) {
			if (tab[i]!=0) taille_res++;
		}
		res = new int[taille_res];
		j = 0;
		for (i=0; i<tab.length; i++) {
			if (tab[i]!=0) {
				res[j] = i;
				j++;
			}
		}
		return res;
	}

	public Case [] liste_des_cases_possibles (Joueur joueur_attaquant) {
		int i, j, h;
		int taille_res = 0;
		Case [] res;

		int [][] plateau = joueur_attaquant.genere_plateau_cases_tentees(joueur_attaquant);

		for (i=0; i<plateau.length; i++) {
			for (j=0; j<plateau[i].length; j++) {
				if (plateau[i][j]==-1) taille_res++;
			}
		}
		res = new Case[taille_res];
		h = 0;
		for (i=0; i<plateau.length; i++) {
			for (j=0; j<plateau[i].length; j++) {
				if (plateau[i][j]==-1) {
					res[h] = new Case(i+1, j+1);
					h++;
				}
			}
		}
		return res;	
	}

	public Case genere_une_case_aleat (Joueur joueur_attaquant) {
		Case [] cases_possibles = liste_des_cases_possibles(joueur_attaquant);
		int choix = randInt(0, cases_possibles.length-1);
		return cases_possibles[choix];
	}

//################### Fonctions utilitaires ####################//

	public void afficher_plateau () {
		afficher_plateau_aux("du plateau (IA)", this.plateau);
	}

	public void afficher_plateau_aux (String nom, int [][] plateau) {
		int i, j;
		int [] t = null;
		if (plateau==null) return;
		if (plateau.length<1) return;
		int hauteur = plateau.length;
		int largeur = plateau[0].length;

		aff("\nAffichage "+nom+" : \n");
		for (i=0; i<hauteur; i++) {
			affnn("  ");
			for (j=0; j<largeur; j++) {
				affnn(""+plateau[i][j]+"   ");
			}
			affnn("\n");
		}
		affnn("\n");
	}

	public void aff_tab (int [] tab, String nom) {
		int i;

		if (tab==null) {
			aff("aff_tab : "+nom+" est null");
			return;
		}
		for (i=0; i<tab.length; i++) {
			aff(nom+"["+i+"] = "+tab[i]);
		}
	}

	public boolean inverse_bool (boolean tmp) {
		if (tmp) return false;
		else return true;
	}

	public boolean is_integer (String s0) {
		try {
			int n1 = Integer.parseInt(s0);
			return true;
		}
		catch (Exception e) {
			return false;
		}
	}

	public int randInt (int min, int max) {
		int tmp;

		if (min==max) return min;
		int res = (int)(Math.random()*max)+min;
		if (res>max) res = max;
		if (res<min) res = min;

		return res;
	}

	/**
		sauf est la tableau de valeurs 
		qui ne doit pas être retourné.
		Sauf est situé entre min et max non-inclus
	**/
	public int randInt_sauf (int min, int max, int [] sauf) {
		int i, j;
		int res;
		int tmp0;
		int taille_de_tmp2;
		int tmp3;

		if (sauf==null) return randInt(min, max);
		if (sauf.length==0) return randInt(min, max);

		// Tri le tableau sauf au cas où 
		// cela ne serait pas le cas.
		//utilitaire.aff_tab("sauf", sauf);
		Arrays.sort(sauf);
		utilitaire.aff_tab("sauf", sauf);

		int [] tmp1 = new int[sauf.length+1];
		int [] tmp2;
		if (min+1==sauf[0]) tmp1[0]=min;
		else tmp1[0] = randInt_trie_valeurs(min, sauf[0]);
		if (sauf.length>1) {
			j = 1;
			for (i=0; i<sauf.length-1; i++) {
				int tmp_12 = randInt_trie_valeurs(sauf[i], sauf[i+1]);
				aff("randInt_trie_valeurs("+sauf[i]+", "+sauf[i+1]+") = "+tmp_12);
				tmp1[j] = tmp_12;
				j++;
			}
		}
		if (max-1==sauf[sauf.length-1]) tmp1[tmp1.length-1]=max;
		else tmp1[tmp1.length-1] = randInt_trie_valeurs(sauf[sauf.length-1], max);
		//utilitaire.aff_tab("tmp1", tmp1);
		taille_de_tmp2 = 0;
		for (i=0; i<tmp1.length; i++) {
			if (tmp1[i]>0) taille_de_tmp2++;
		}
		if (taille_de_tmp2==0) {
			//aff("randInt_sauf : tous les chiffres entre min et max sont indisponibles (sont dans sauf)");
			return -1;
		}
		tmp2 = new int[taille_de_tmp2];
		j = 0;
		for (i=0; i<tmp1.length; i++) {
			if (tmp1[i]>0) {
				tmp2[j] = tmp1[i];
				j++;
			}
		}
		utilitaire.aff_tab("tmp2", tmp2);
		tmp3 = randInt(0, tmp2.length-1);
		res = tmp2[tmp3];
		if (res>max) res = max;
		if (res<min) res = min;
		return res;
	}

	/**
		Donne -1 si les valeurs min et max sont consécutives.
	**/
	public int randInt_trie_valeurs (int min, int max) {
		int tmp;
		if (min>max || min==max) {
			if (min>max) {
				//aff("randInt_trie_valeurs : Erreur, min>max");
			}
			else {
				//aff("min==max");
			}
			//aff("min = "+min);
			//aff("max = "+max);
			if ((max+1)==min) return -1;
		}
		if ((min+1)==max || min==max) return -1;
		else return randInt(min, max);
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1.4 (Jeu finit (amÃ©liorÃ©), IA - en cours)/src/Jeu.java

class Jeu {
	Menu menu;
	Affichage affichage;
	Utilitaire utilitaire;
	Grille grille;
	int hauteur;
	int largeur;
	int nombre_de_joueurs;
	Joueur [] joueurs;
	IA ia;

	public Jeu (int hauteur, int largeur, int nombre_de_joueurs) {
		this.hauteur = hauteur;
		this.largeur = largeur;
		this.nombre_de_joueurs = nombre_de_joueurs;
	}

	public void definition_du_jeu () {
		int choix = 1;
		int options = 0;
		int [] taille_plateau;
		menu = new Menu();
		affichage = new Affichage();
		utilitaire = new Utilitaire();
		grille = new Grille(hauteur, largeur);
		ia = new IA(grille);

		while (choix!=3) {
			choix = menu.menu_principal();
			//choix = 1;
			if (choix==2) {
				nombre_de_joueurs = menu.entre_nombre_de_joueurs();
			}
			if (choix==1 || choix==2) {
				initialisation_du_jeu(nombre_de_joueurs);
				jeu(nombre_de_joueurs);
			}
			if (choix==3) {
				options = menu.options();
				if (options==1) {
					taille_plateau = menu.choisir_taille_plateau();
					this.hauteur = taille_plateau[0];
					this.largeur = taille_plateau[1];
				}
			}
			if (choix==4) affiche_instuctions();
			// Le joueur a choisi de quitter le jeu
			if (choix==5) {
				System.exit(0);
			}
		}
	}

	public void affiche_instuctions () {
		aff("\nLe joueur qui gagne est le dernier à perdre.");
		aff("Un joueur perd s'il n'a plus aucun bateau (non coulé).\n");
	}

	public void initialisation_du_jeu (int nombre_de_joueurs) {
		int i, q=0;
		boolean joueur_IA_humain;
		boolean carte_a_montrer;
		boolean placement_auto_humain = false;
		

		joueurs = new Joueur[nombre_de_joueurs];
		for (i=0; i<nombre_de_joueurs; i++) {
			joueur_IA_humain = menu.IA_humain((i+1));
			carte_a_montrer = !joueur_IA_humain;
			//joueur_IA_humain = true;
			if (!joueur_IA_humain)
				q = menu.menu_positionnement_bateaux_1((i+1));
			else q = 2;
			//q = 2;
			if (q==2) placement_auto_humain = true;
			joueurs[i] = placement_bateaux ((i+1), placement_auto_humain, joueur_IA_humain, carte_a_montrer);
			affichage.afficher_carte_joueur(grille, joueurs[i]);
		}
	}

	/**
		placement_auto_humain :
			True : automatique
			False : humain
	**/
	public Joueur placement_bateaux (int numero_du_joueur, boolean placement_auto_humain, boolean IA_humain, boolean carte_a_montrer) {
		Joueur res;
		if (!placement_auto_humain)
			res = new Joueur(numero_du_joueur, grille, IA_humain, carte_a_montrer);
		else res = ia.place_bateaux_IA(grille, numero_du_joueur, IA_humain, carte_a_montrer);
		return res;
	}

	public void jeu (int nombre_de_joueurs) {
		int i, j;
		int gagnant;
		int nombre_de_joueurs_ayant_perdu = 0;
		boolean impossible_de_tenter_une_case = false;
		boolean fin_du_jeu = false;

		while (!fin_du_jeu) {
			for (i=0; i<nombre_de_joueurs; i++) {
				for (j=0; j<nombre_de_joueurs; j++) {
					if (i!=j && !fin_du_jeu) {
						// IA
						if (joueurs[i].IA_humain) {
							impossible_de_tenter_une_case = (!joueurs[i].tenter_une_case_IA(joueurs[j]));
						}
						// Humain
						else {
							impossible_de_tenter_une_case = (!joueurs[i].tenter_une_case(joueurs[j]));
						}
						//joueurs[j].affiche_status_bateaux();
						utilitaire.afficher_evenement_coup(joueurs[j].derniere_case_tentee);
						affichage.afficher_carte_joueur (grille, joueurs[j]);
						if (impossible_de_tenter_une_case) {
							joueurs[i].perd();
						}
						if (joueurs[j].a_perdu()) {
							//aff("\nLe joueur "+(j+1)+" a perdu !\n");
							nombre_de_joueurs_ayant_perdu++;
						}
						// Vérifie si le jeu est terminé
						if (nombre_de_joueurs_ayant_perdu==nombre_de_joueurs-1 
									|| impossible_de_tenter_une_case) {
							aff("\nFin du jeu");
							gagnant = utilitaire.recherche_gagnant (this.joueurs)+1;
							if (gagnant>0)
								aff("\nLe gagnant est le joueur "+gagnant+".\n");
							else
								aff("\nIl n'y a aucun gagnant.\n");
							fin_du_jeu = true;
						}
					}
				}
			}
		}
		// Affichage de la carte d'attaque du dernier coup
		for (i=0; i<nombre_de_joueurs; i++) {
			joueurs[i].affiche_plateau_attaquant(joueurs[i]);
		}
			
		// Affichage des cartes des joueurs à la fin du jeu
		for (i=0; i<nombre_de_joueurs; i++) {
			joueurs[i].carte_a_montrer = true;
			affichage.afficher_carte_joueur(grille, joueurs[i]);
		}
	}

// ###################### Main ###################### //

	public static void main (String [] args) {
		Jeu jeu = new Jeu(4, 4, 2);
		while (true) {
			jeu.definition_du_jeu();
		}
	}

// ################### Fonctions utilitaires ###################### //

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}	
}

# ./1.4 (Jeu finit (amÃ©liorÃ©), IA - en cours)/src/Joueur.java

class Joueur {
	int numero_du_joueur;
	Affichage affichage;
	Menu menu;
	Utilitaire utilitaire;
	public boolean IA_humain;
	public Case [][] plateau;
	public Case [] cases_occupees;
	public Case [] cases_tentees;
	public int cases_tentees_indice;
	public boolean a_perdu;
	Bateau [] bateaux;
	public int derniere_case_tentee;
	Grille grille;
	/**
		true : Monter les deux cartes
		false : ne pas les montrer
	**/
	public boolean carte_a_montrer;

	public Joueur (int numero_du_joueur, Grille grille, boolean IA_humain, boolean carte_a_montrer) {
		constructeur(grille, numero_du_joueur, IA_humain, carte_a_montrer);
		place_bateaux();
	}

	public Joueur (int numero_du_joueur, Grille grille, Bateau[] bateaux, boolean IA_humain, boolean carte_a_montrer) {
		constructeur(grille, numero_du_joueur, IA_humain, carte_a_montrer);
		this.bateaux = bateaux;
		cases_occupees = utilitaire.cases_occuppees(this);
		plateau = utilitaire.construit_plateau(this);
	}

	public void constructeur (Grille grille, int numero_du_joueur, boolean IA_humain, boolean carte_a_montrer) {
		/**
			-1 : Pas de dernière case tentée
			 0 : dans l'eau
			 1 : touché
			 2 : coulé
		**/
		this.IA_humain = IA_humain;
		this.carte_a_montrer = carte_a_montrer;
		derniere_case_tentee = -1;
		a_perdu = false;
		this.grille = grille;
		this.numero_du_joueur = numero_du_joueur;
		utilitaire = new Utilitaire();
		affichage = new Affichage();
		menu = new Menu();
		cases_tentees = new Case[grille.hauteur*grille.largeur];
		cases_tentees_indice = 0;
	}

// ################ Fonctions utilitaires du jeu ################ //

	public Bateau place_bateau (int numero_du_bateau, int nombre_de_cases) {
		boolean placement_correct_incorrect = false;
		Case [] cases;
		int [] cases_bateau = null;
		int [] case_1 = new int[2];
		int [] case_fin = new int[2];
		while (!placement_correct_incorrect) {
			cases_bateau = menu.donne_cases_bateau(grille, numero_du_bateau, nombre_de_cases);
			case_1[0] = cases_bateau[0];
			case_1 [1] = cases_bateau[1];
			case_fin[0] = cases_bateau[2];
			case_fin[1] = cases_bateau[3];

			placement_correct_incorrect = utilitaire.verifie_placement_bateau (case_1, 
									case_fin, nombre_de_cases);
			if (!placement_correct_incorrect) {
				aff("Placement incorrect");
			}
		}
		cases = utilitaire.donne_cases_bateau(cases_bateau, nombre_de_cases);
		Bateau bateau = new Bateau(cases);
		return bateau;
	}

	/**
		Renvoie un int :
		0 : dans l'eau
		1 : touché
		2 : coulé
	**/
	public int attaquer_une_case (Case case_attaquee) {
		int i;
		int ordonnee_attaquee = utilitaire.formate_int(0, grille.hauteur, case_attaquee.ordonnee-1);
		int abscisse_attaquee = utilitaire.formate_int(0, grille.largeur, case_attaquee.abscisse-1);
		int bateau_attaque = -1;
		int derniere_case_tentee = -1;
		Case case_tmp = new Case();
		//aff("case_tmp : "+case_tmp.toString());

		for (i=0; i<cases_occupees.length; i++) {
			if (case_tmp.compare_case(cases_occupees[i], case_attaquee)) {
				cases_occupees[i].attaquer();
				//aff("cases_occupees[i] : "+cases_occupees[i].toString());
				
				derniere_case_tentee = 1;
			}
		}
		for (i=0; i<bateaux.length; i++) {
			if (bateaux[i].attaque(case_attaquee)) {
				bateau_attaque = i;
			}
			if (bateau_attaque!=-1) {
				if (bateaux[bateau_attaque].est_coule()) {
					derniere_case_tentee = 2;
					met_a_jour_plateau_coule();
				}
			}
		}
		plateau[ordonnee_attaquee][abscisse_attaquee].attaquer();
		//aff("plateau[ordonnee_attaquee][abscisse_attaquee] : "+plateau[ordonnee_attaquee][abscisse_attaquee].toString());
		if (derniere_case_tentee==-1) {
			this.derniere_case_tentee = 0;
			return 0;
		}
		else {
			this.derniere_case_tentee = derniere_case_tentee;
			return derniere_case_tentee;
		}
	}

	public void place_bateaux () {
		int i;
		boolean ok=false;
		Case case_tmp = new Case();
		Bateau bateau_tmp = new Bateau(), bateau_tmp2 = null;
		int [] tab_nombre_cases_bateaux = bateau_tmp.donne_nombre_de_cases_bateaux(this.grille);
		int nombre_de_bateaux = tab_nombre_cases_bateaux.length;
		this.bateaux = new Bateau[nombre_de_bateaux];
		affichage.afficher_carte_joueur(this.grille, this);
		for (i=0; i<nombre_de_bateaux; i++) {
			ok = false;
			while(!ok) {
				bateau_tmp2 = place_bateau((i+1), tab_nombre_cases_bateaux[i]);
				cases_occupees = utilitaire.cases_occuppees(this);
				if (!case_tmp.contient_case(cases_occupees, bateau_tmp2.cases)) ok=true;
				if (!ok)
					aff("Il y a déjà un bateau placé là");
				bateaux[i] = bateau_tmp2;
			}
			cases_occupees = utilitaire.cases_occuppees(this);
			plateau = utilitaire.construit_plateau(this);
			affichage.afficher_carte_joueur(this.grille, this);
		}
	}

	public int [][] genere_plateau_cases_tentees (Joueur joueur_attaquant) {
		int [][] plateau = joueur_attaquant.construit_plateau_cases_tentees();
		return plateau;
	}

	public void affiche_plateau_attaquant (Joueur joueur_attaquant) {
		Affichage affichage = new Affichage();

		int [][] plateau = genere_plateau_cases_tentees(joueur_attaquant);

		affichage.afficher_carte_attaque_joueur (plateau, joueur_attaquant.numero_du_joueur);
	}

	public boolean tenter_une_case_IA (Joueur joueur_attaque) {
		int etat_case = -1;
		IA ia_tmp = new IA(grille);
		if (carte_a_montrer) affiche_plateau_attaquant(this);
		Case case_tentee = new Case(-1, -1);
		// Vérifie s'il reste des cases à tenter sur le plateau.
		if (cases_a_tenter()) {
			case_tentee = ia_tmp.genere_une_case_aleat(this);
			aff("Joueur "+this.numero_du_joueur+" : ");
			aff("? = "+(char)(('A'+case_tentee.ordonnee-1))+case_tentee.abscisse);
			//aff(case_tentee.aff_case_str());
			etat_case = joueur_attaque.attaquer_une_case(case_tentee);
			ajoute_une_case_tentee(this, case_tentee, etat_case);
			return true;
		}
		else {
			aff("Joueur "+numero_du_joueur+", tenter_une_case : toutes les cases du plateau ont été tentées");
			return false;
		}
	}

	public boolean tenter_une_case (Joueur joueur_attaque) {
		int etat_case = -1;
		int [] tmp;
		IA ia_tmp = new IA(grille);
		boolean case_en_double = false;
		Case case_tentee = new Case(-1, -1);
		if (carte_a_montrer) affiche_plateau_attaquant(this);
		// Vérifie s'il reste des cases à tenter sur le plateau.
		if (cases_a_tenter()) {
			case_en_double = true;
			while (case_en_double) {
				tmp = menu.entre_case(grille, "Joueur "+numero_du_joueur+" : \nEntrer la case à jouer");
				case_tentee = new Case(tmp[0], tmp[1]);
				if (!utilitaire.verifie_case_tentee(this.cases_tentees, cases_tentees_indice, case_tentee)) {
					case_en_double = true;
					aff("Attention, la case "+case_tentee.case_format_ecrit()+" a déjà été tentée.");
					aff("Veuillez entrer une autre case :");
				}
				else case_en_double = false;
			}
			etat_case = joueur_attaque.attaquer_une_case(case_tentee);
			ajoute_une_case_tentee(joueur_attaque, case_tentee, etat_case);
			return true;
		}
		else {
			aff("Joueur "+numero_du_joueur+", tenter_une_case : toutes les cases du plateau ont été tentées");
			return false;
		}
	}

	/**
		Met à jour les bateaux coulés sur le plateau
	**/
	public void met_a_jour_plateau_coule () {
		int i, j;
		int ordonnee;
		int abscisse;

		for (i=0; i<bateaux.length; i++) {
			if (bateaux[i].est_coule()) {
				for (j=0; j<bateaux[i].cases.length; j++) {
					ordonnee = bateaux[i].cases[j].ordonnee-1;
					abscisse = bateaux[i].cases[j].abscisse-1;

					plateau[ordonnee][abscisse].couler();
				}
			}
		}
	}

	public void perd () {
		this.a_perdu = true;
	}

	public boolean a_perdu () {
		int i;

		if (a_perdu) return true;
		for (i=0; i<bateaux.length; i++) {
			//aff("bateaux[i].est_coule() : "+bateaux[i].est_coule());
			if (!bateaux[i].est_coule()) return false;
		}
		perd();
		return true;
	}

	/**
		0 : case non-tentée
		1 : case tentée
	**/
	public int [][] construit_plateau_cases_tentees () {
		int i, j;
		int ordonnee;
		int abscisse;
		int etat;

		Case case_tmp = new Case();

		int [][] plateau = new int[grille.hauteur][grille.largeur];

		// Initialisation du plateau
		for (i=0; i<plateau.length; i++) {
			for (j=0; j<plateau[i].length; j++) {
				plateau[i][j] = -1;
			}
		}

		// On met les cases tentées dans le plateau
		for (i=0; i<cases_tentees_indice; i++) {
			ordonnee = cases_tentees[i].ordonnee-1;
			abscisse = cases_tentees[i].abscisse-1;
			etat = cases_tentees[i].etat;

			plateau[ordonnee][abscisse] = etat;
		}
		return plateau;
	}

	public Case [] liste_des_cases_coulees () {
		int i, j, h;
		int nombre_de_cases = 0;

		Case [] res;
		for (i=0; i<bateaux.length; i++) {
			if (bateaux[i].coule)
				nombre_de_cases+=bateaux[i].nombre_de_cases;
		}
		res = new Case[nombre_de_cases];
		h = 0;
		for (i=0; i<bateaux.length; i++) {
			if (bateaux[i].coule) {
				for (j=0; j<bateaux[i].cases.length; j++) {
					res[h] = bateaux[i].cases[j];
					h++;
				}
			}
		}
		return res;
	}

	/**
		Met à jour les cases coulée dans les cases tentées 
		pour l'affichage de la carte des cases tentées
	**/
	public void met_a_jour_cases_coulees (Joueur joueur_attaque) {
		int i, j;
		Case case_tmp = new Case();

		Case [] cases_coulees = joueur_attaque.liste_des_cases_coulees();
		for (i=0; i<cases_coulees.length; i++) {
			for (j=0; j<cases_tentees_indice; j++) {
				if (case_tmp.compare_case(cases_coulees[i], cases_tentees[j])) {
					cases_tentees[j].couler(); 
					cases_tentees[j].etat = 2;
				}
			}
		}
	}

// ################### Fonctions utilitaires ###################### //

	/**
		Retourne true s'il reste des cases à tenter
		false sinon.
	**/
	public boolean cases_a_tenter () {
		return (cases_tentees_indice<cases_tentees.length);
	}

	public boolean ajoute_une_case_tentee (Joueur joueur_attaque, Case case_tentee, int etat_case) {
		if (etat_case==2)
			met_a_jour_cases_coulees(joueur_attaque);
		if (!cases_a_tenter()) return false;
		else {
			case_tentee.etat = etat_case;
			cases_tentees[cases_tentees_indice++] = case_tentee;
			return true;
		}
	}

	public void affiche_status_bateaux () {
		int i;

		for (i=0; i<bateaux.length; i++) {
			aff("Bateau "+(i+1)+" : ");
			bateaux[i].aff_cases_touchee();
		}
	}

	public void affiche_espaces (int nombre_d_espaces) {
		int i;

		for (i=0; i<nombre_d_espaces; i++) {
			affnn(" ");
		}
	}

	public void affiche_sauts_de_ligne (int nombre_de_lignes) {
		int i;

		for (i=0; i<nombre_de_lignes; i++) {
			affnn("\n");
		}
	}

	public String toString() {
		String res = ""+numero_du_joueur;
		return res;
	}

	public int get_numero_du_joueur () {
		return this.numero_du_joueur;
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1.4 (Jeu finit (amÃ©liorÃ©), IA - en cours)/src/Menu.java

import java.util.Scanner;

class Menu {
	Utilitaire utilitaire;
	Case case_1;

	public Menu () {
		this.case_1 = new Case();
		this.utilitaire = new Utilitaire();
	}

	public int menu_principal () {
		int res=-1;
		aff("\n   ******* Menu principal ******* \n");
		while (res!=1 && res!=2 && res!=3 && res!=4 && res!=5) {
			aff("\t1 : Jouer");
			aff("\t2 : Jouer à plus de deux joueurs");
			aff("\t3 : Options");
			aff("\t4 : Instructions");
			aff("\t5 : Quitter");
			affnn("\n   ");
			res = entrer_entier("entre 1 et 5");
		}
		return res;
	}

	public int options () {
		int res=-1;
		aff("\n   ********** Options ********** \n");
		while (res!=1) {
			aff("\t1 : Choisir la taille du plateau");
			affnn("\n   ");
			res = entrer_entier("entre 1 et 1");
		}
		return res;
	}

	public int [] choisir_taille_plateau () {
		int [] res = new int[2];
		int hauteur = -1;
		int largeur = -1;
		while (hauteur<1) {
			aff("Entrer la hauteur du plateau :");
			affnn("\n   ");
			hauteur = entrer_entier("suppérieur à 0");
		}
		while (largeur<1) {
			aff("Entrer la largeur du plateau :");
			affnn("\n   ");
			largeur = entrer_entier("suppérieur à 0");
		}
		res[0] = hauteur;
		res[1] = largeur;
		return res;
	}

// ###################### Fonctions du jeu ######################## //

// ###******** Fonctions de positionnements des bateaux ********### //

	public int menu_positionnement_bateaux_1 (int numero_du_joueur) {
		int res=-1;	
		aff("\n   ******* Menu joueur 2 ******* \n");
		aff("Le joueur "+numero_du_joueur+" doit :");
		while (res!=1 && res!=2) {
			aff("\t1 : Placer ses bateau soi-même");
			aff("\t2 : Placer ses bateau aléatoirement");
			affnn("\n   ");
			res = entrer_entier("entre 1 et 2");
		}
		return res;
	}

	public int menu_IA_humain (int numero_du_joueur) {
		int res=-1;	
		aff("\n   ******* Menu joueur 1 ******* \n");
		aff("Le joueur "+numero_du_joueur+" est un :");
		while (res!=1 && res!=2) {
			aff("\t1 : Joueur humain");
			aff("\t2 : joueur IA");
			affnn("\n   ");
			res = entrer_entier("entre 1 et 2");
		}
		return res;
	}

	public boolean IA_humain (int numero_du_joueur) {
		int q = menu_IA_humain(numero_du_joueur);
		if (q==1) return false;
		else return true;
	}

	public int entre_nombre_de_joueurs () {
		int res = -1;
		aff("\nEntrer le nombre de joueurs :");
		while (res<2) {
			res = entrer_entier(" suppérieur à ou égal 2");
		}
		return res;
	}

	public int entre_nombre_de_bateaux (int nombre_de_cases_restantes) {
		int res = -1;

		while (res<1 || res>nombre_de_cases_restantes) {
			aff("Veuillez entrer le nombre de bateaux :");
			res = entrer_entier_phrase("inférieur ou égal à "+nombre_de_cases_restantes+" et suppérieur à 0");
		}
		return res;
	}

	public int entre_nombre_de_case_bateau (Grille grille, int numero_du_bateau, 
			int nombre_de_cases_restantes, int nombre_de_bateaux_restants) {
		int res = -1;
		Bateau bateau_tmp = new Bateau();
		int chiffre_a_entrer_inferieur_a = bateau_tmp.taille_max_bateau(grille, 
				nombre_de_cases_restantes-(nombre_de_bateaux_restants-1));
		while (res<1 || res>chiffre_a_entrer_inferieur_a) {
			aff("Entrer le nombre de cases du bateau "+numero_du_bateau+" : ");
			res = entrer_entier_phrase("inférieur ou égal à "+chiffre_a_entrer_inferieur_a+" et suppérieur à 0");
		}
		return res;
	}

	/**
		Donne les bateaux d'un joueur
		Chaque case du tableau int[] 
		contient le nombre du case d'un bateau.
	**/
	public int[] entre_nombre_de_case_bateaux (Grille grille, int nombre_de_cases_restantes) {
		int i;
		int tmp;
		int [] res;
		int nombre_de_cases_restantes_tmp = nombre_de_cases_restantes;
		int nombre_de_bateaux_restants;

		aff("Il vous reste "+nombre_de_cases_restantes+" cases à occuper avec vos bateaux.");
		int nombre_de_bateaux = entre_nombre_de_bateaux(nombre_de_cases_restantes);
		nombre_de_bateaux_restants = nombre_de_bateaux;
		res = new int[nombre_de_bateaux];
		for (i=0; i<nombre_de_bateaux ; i++) {
			tmp = entre_nombre_de_case_bateau(grille, (i+1), nombre_de_cases_restantes_tmp, nombre_de_bateaux_restants);
			res[i] = tmp;
			nombre_de_cases_restantes_tmp-=tmp;
			nombre_de_bateaux_restants--;
		}
		return res;
	}

	/**
		Donne la pemière et la dernière case 
		du bateau.
		Renvoie un int [] :
			int[0] : première case, ordonnée
			int[1] : première case, abscisse
			int[2] : deuxième case, ordonnée
			int[3] : deuxième case, abscisse
	**/
	public int [] donne_cases_bateau (Grille grille, int numero_du_bateau, int nombre_de_cases_bateau) {
		String message = "Entrer la première case du bateau numéro "+numero_du_bateau+" à "+nombre_de_cases_bateau+" case(s) : ";
		int [] case1 = entre_case(grille, message);
		message = "Entrer la dernière case du bateau numéro "+numero_du_bateau+" à "+nombre_de_cases_bateau+" case(s) : ";
		int [] case_fin = entre_case(grille, message);
		int [] res = new int[4];

		res[0] = case1[0];
		res[1] = case1[1];
		res[2] = case_fin[0];
		res[3] = case_fin[1];

		return res;
	}

	public int [] entre_case (Grille grille, String message) {
		int i = 0;
		Scanner sc = new Scanner(System.in);
		String reponse = "";
		affnn(message+"\n? = ");
		while (!case_1.verifie_case_existe(grille, reponse)) {
			if (i>0 && !case_1.verifie_case_existe(grille, reponse))
				affnn("Format de case incorrect\n? = ");
			reponse = sc.nextLine();
			i++;
		}
		return case_1.convertit_case_en_coordonnee(grille, reponse);
	}

// ################### Fonctions utilitaires ###################### //

	public int entrer_entier (String precision) {
		Scanner sc = new Scanner(System.in);
		String res = "";

		affnn("? = ");
		res = sc.nextLine();
		while (!is_integer(res)) {
			aff("Veuillez entrer en entier "+precision+" : ");
			affnn("? = ");
			res = sc.nextLine();
		}
		return Integer.parseInt(res);
	}

	public int entrer_entier_phrase (String precision) {
		Scanner sc = new Scanner(System.in);
		String res = "";

		aff("Veuillez entrer en entier "+precision+" : ");
		affnn("? = ");
		res = sc.nextLine();
		while (!is_integer(res)) {
			aff("Veuillez entrer en entier "+precision+" : ");
			affnn("? = ");
			res = sc.nextLine();
		}
		return Integer.parseInt(res);
	}

	public boolean is_integer (String s0) {
		try {
			int n1 = Integer.parseInt(s0);
			return true;
		}
		catch (Exception e) {
			return false;
		}
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./1.4 (Jeu finit (amÃ©liorÃ©), IA - en cours)/src/Test.java

import java.util.Arrays;

class Test {
	IA ia;
	public Test () {
		//int i;
		//ia = new IA();
		//Utilitaire ut = new Utilitaire();

		/*int [] tmp = {2, 4, 1};

		Arrays.sort(tmp);

		for (i=0; i<tmp.length; i++) {
			aff("tmp["+i+"] = "+tmp[i]);
		}
		int taille_du_bateau = 2;
		int [] tab = {0, 0, 0, 0, 0 };
		ia.scanne_ligne_colonne (tab, taille_du_bateau);
		aff("Case = "+ut.convertit_coordonnees_str(4, 4));
		int [] test = new int[0];
		aff("test.length = "+test.length);
		aff("test[0] = "+test[0]);
		int [] tab = {1, 2};
		aff("tab = "+tab[0].toString());*/
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}

	public static void main (String [] args) {
		Test test = new Test();
	}
}

# ./1.4 (Jeu finit (amÃ©liorÃ©), IA - en cours)/src/Utilitaire.java

class Utilitaire {

	public Utilitaire() {}

//################ Fonctions utilitaires du jeu ################//

	public boolean tmp () {
		return true;
	}

	public boolean compare_coordonneee (int ordonnee_source, int abscisse_source, int ordonnee_but, int abscisse_but) {
		return (ordonnee_source==ordonnee_but &&
			abscisse_source==abscisse_but);
	}

	/**
		Un bateau peut être soit horizontal ou vertical soit oblique.
		Cas :

		case_fin est égale à case_1
		case_fin à gauche de case_1
		case_fin à droite de case_1
		case_fin en haut de case_1
		case_fin en bas de case_1		
	**/
	public boolean verifie_placement_bateau (int [] case_1, int [] case_fin, int nombre_de_cases) {
		int tmp = 0;

		if (case_1[0]==case_fin[0] && case_1[1]==case_fin[1]) {
			if (nombre_de_cases==1) return true;
			else return false;
		}
		//Horizontal
		if (case_1[0]==case_fin[0]) {
			//case_fin à gauche de case_1
			if (case_fin[1]<case_1[1]) {
				tmp = case_1[1]-case_fin[1];
				if (tmp==nombre_de_cases && tmp>0) return true;
				else return false;
			}
			//case_fin à droite de case_1
			if (case_fin[1]>case_1[1]) {
				tmp = case_fin[1]-case_1[1];
				if (tmp==nombre_de_cases && tmp>0) return true;
				else return false;
			}
		}
		//Vertical
		if (case_1[1]==case_fin[1]) {
			//case_fin en haut de case_1
			if (case_fin[0]<case_1[0]) {
				tmp = case_1[1]-case_fin[1];
				if (tmp==nombre_de_cases && tmp>0) return true;
				else return false;
			}
			//case_fin en base de case_1
			if (case_fin[0]>case_1[0]) {
				tmp = case_fin[1]-case_1[1];
				if (tmp==nombre_de_cases && tmp>0) return true;
				else return false;
			}
		}
		return false;
	}

	/**
		Prend un tableau de 4 int tel que :
		t[0] = case_1_ordonnee
		t[1] = case_1_abscisse
		t[2] = case_fin_ordonnee
		t[3] = case_fin_abscisse

		renvoie l'ensemble des cases du bateau.
	**/
	public Case [] donne_cases_bateau (int [] cases, int nombre_de_cases) {
		int i;
		int [] case_1 = {cases[0], cases[1]};
		int [] case_fin = {cases[2], cases[3]};;
		Case [] res = new Case[nombre_de_cases];

		if (case_1[0]==case_fin[0] && case_1[1]==case_fin[1]) {
			res[0] = new Case(cases[0], cases[1]);
		}
		//Horizontal
		if (case_1[0]==case_fin[0]) {
			//case_fin à gauche de case_1
			if (case_fin[1]<case_1[1]) {
				for (i=0; i<nombre_de_cases; i++) {
					res[i] = new Case(case_1[0], case_1[1]-i);
				}
			}
			//case_fin à droite de case_1
			if (case_fin[1]>case_1[1]) {
				for (i=0; i<nombre_de_cases; i++) {
					res[i] = new Case(case_1[0], case_1[1]+i);
				}
			}
		}
		//Vertical
		if (case_1[1]==case_fin[1]) {
			//case_fin en haut de case_1
			if (case_fin[0]<case_1[0]) {
				for (i=0; i<nombre_de_cases; i++) {
					res[i] = new Case(case_1[0]-i, case_1[1]);
				}
			}
			//case_fin en bas de case_1
			if (case_fin[0]>case_1[0]) {
				for (i=0; i<nombre_de_cases; i++) {
					res[i] = new Case(case_1[0]+i, case_1[1]);
				}
			}
		}
		return res;
	}

	/**
		Remplit un tableau de Case[] des cases 
		occupées pour rendre accessible un Bateau, 
		une Case et un Joueur à partir d'un même objet.
		
	**/
	public Case [] cases_occuppees (Joueur joueur) {
		int i, j, h;
		int nombre_de_bateaux_initialises = 0;
		int ordonnee, abscisse;
		int nombre_total_de_cases = 0;
		Case [] res;
		Bateau [] bateaux = joueur.bateaux;
		for (i=0; i<bateaux.length; i++) {
			if (bateaux[i]!=null) {
				nombre_de_bateaux_initialises+=1;
			}
		}

		/**
			Compte le nombre total de cases.
		**/
		for (i=0; i<nombre_de_bateaux_initialises; i++) {
			if (bateaux[i]!=null)
				nombre_total_de_cases+=bateaux[i].cases.length;
		}
		res = new Case[nombre_total_de_cases];
		h = 0;
		for (i=0; i<nombre_de_bateaux_initialises; i++) {
			if (bateaux[i]!=null) {
				for (j=0; j<bateaux[i].cases.length; j++) {
					if (bateaux[i]!=null) {
						ordonnee = bateaux[i].cases[j].ordonnee;
						abscisse = bateaux[i].cases[j].abscisse;
						res[h] = new Case(joueur, bateaux[i], 
							(i+1), ordonnee, abscisse);
					h++;
					}
				}
			}
		}
		return res;		
	}

	/**
		Si trouve la case recherchée, la retourne,
		sinon retourne null.
	**/
	public Case cherche_case (Case [] cases, Case case_1) {
		int i;
		Case res = null;

		for (i=0; i<cases.length; i++) {
			if ((new Case()).compare_case (cases[i], case_1)) return cases[i];
		}
		return res;
	}

	/**
		Construit un plateau pour chaque joueur
		en fonction de ses bateaux.
	**/
	public Case [][] construit_plateau (Joueur joueur) {
		int i, j;
		Case case_tmp, case_tmp2;

		Case [][] plateau = new Case[joueur.grille.hauteur][joueur.grille.largeur];

		for (i=0; i<plateau.length; i++) {
			for (j=0; j<plateau[i].length; j++) {
				case_tmp = new Case((i+1), (j+1));
				case_tmp2 = cherche_case(joueur.cases_occupees, case_tmp);
				if (case_tmp2!=null)
					plateau[i][j] = case_tmp2;
				else plateau[i][j] = case_tmp;
			}
		}
		return plateau;
	}

	/**
		Recherche le premier joueur du tableau 
		qui n'a pas perdu. Renvoie son emplacement 
		dans le tableau.
	**/
	public int recherche_gagnant (Joueur [] joueurs) {
		int i;

		for (i=0; i<joueurs.length; i++) {
			if (!joueurs[i].a_perdu()) return i;
		}
		return -1;
	}

	/**
		Retourne false si la case tentée a déjà été tentée,
		true sinon.
	**/
	public boolean verifie_case_tentee (Case [] cases_tentees, int cases_tentees_indice, Case case_tentee) {
		int i;
		Case case_tmp = new Case();

		for (i=0; i<cases_tentees_indice; i++) {
			if (case_tmp.compare_case(cases_tentees[i], case_tentee)) return false;
		}
		return true;
	}

	public String convertit_coordonnees_str (int ordonnee, int abscisse) {
		return ""+(char)('A'+ordonnee-1)+abscisse;
	}

	/**
		-1 : rien
		 0 : dans l'eau
		 1 : touché
		 2 : coulé
	**/
	public void afficher_evenement_coup (int tmp) {
		String res = "";

		if (tmp==0) res = "Dans l'eau !";
		if (tmp==1) res = "Touché !";
		if (tmp==2) res = "Coulé !";

		aff("\n\t\t"+res+"\n");
	}

//################### Fonctions utilitaires ####################//

	public void aff_tab (String nom, Case [] cases) {
		aff_tab(nom, cases, cases.length);
	}

	public void aff_tab (String nom, Case [] cases, int cases_tentees_indice) {
		int i;
		int cases_tentees_indice_tmp = Math.min(cases_tentees_indice, cases.length);

		for (i=0; i<cases_tentees_indice_tmp; i++) {
			if (cases[i]==null)
				aff(nom+"["+i+"] = null");
			else aff(nom+"["+i+"] = \n"+cases[i].aff_case_str());
		}
	}

	public void aff_tab (String nom, int [] tab) {
		int i;
		for (i=0; i<tab.length; i++) {
			aff(nom+"["+i+"] = "+tab[i]);
		}
	}

	public boolean is_integer (String s0) {
		try {
			int n1 = Integer.parseInt(s0);
			return true;
		}
		catch (Exception e) {
			return false;
		}
	}

	public int randInt (int min, int max) {
		int res = (int)(Math.random()*max)+min;
		if (res>max) res = max;
		if (res<min) res = min;

		return res;
	}

	public int formate_int (int min, int max, int tmp) {
		int res = tmp;
		if (res<min)
			res = min;
		if (res>max)
			res = max;
		return res;
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}
}

# ./Tests/Test.java

import java.util.Arrays;

class Test {
	IA ia;
	public Test () {
		int i;
		ia = new IA();

		int [] tmp = {2, 4, 1};

		Arrays.sort(tmp);

		for (i=0; i<tmp.length; i++) {
			aff("tmp["+i+"] = "+tmp[i]);
		}
	}

	public void aff (String oo) {
		System.out.println(oo);
	}

	public void affnn (String oo) {
		System.out.print(oo);
	}

	public static void main (String [] args) {
		Test test = new Test();
	}
}

# ./Calendrier.txt

Commencé mardi 3/12/2019
1.2 commencé le 5/12/2019
1.2 -> jeu jouable le 12/12/2019

- Jeu avec IA aléatoire et bateaux
placés automatiquement avec un espacement de 1 entre eux
- Ne bug pas lorsque le nombre de bateaux
initialement déterminé par l'IA n'a pas pu
être placé -> met moins de bateaux.

1.4 (IA) prêt à être entammé le 12/12/2019

Objectif : l'IA doit être capable de jouer
un bateaux entier d'affilé si elle touche une
case avec probabilité d'erreur (car elle n'a pas accès
aux cases exactes du bateau mais voit la même choses que
n'importe quel autre joueur).

Travaillé chaque jour environs de 3 à 6 heures par jour

Pause le lundi 9/12/2019

-> 10 jours de dev à ce jour.

# ./projet.txt



# ./1 (premiÃ¨res bases)/BAT/Compile et execute.bat

@echo off

cls&&cd ..\src && javac *.java -d "../class" && cd ../BAT && java -cp "../class" Jeu
cd ../BAT

# ./1 (premiÃ¨res bases)/BAT/Compile.bat

@echo off

cls&&cd ..\src && javac Affichage.java -d "../class" && javac Bateau.java -d "../class" && javac Grille.java -d "../class" && javac Jeu.java -d "../class" && javac Main.java -d "../class" && javac Menu.java -d "../class" && javac -d "../class" Utilitaire.java && cd ../BAT
cd ../BAT

# ./1 (premiÃ¨res bases)/BAT/Executer.bat

@echo off

java -cp "../class" Jeu


# ./1 (premiÃ¨res bases)/Jouer.bat

@echo off

java -cp "class" Jeu


# ./1.2 (Jeu finit)/BAT/Compile et execute.bat

@echo off

cls&&cd ..\src && javac *.java -d "../class" && cd ../BAT && java -cp "../class" Jeu
cd ../BAT

# ./1.2 (Jeu finit)/BAT/Compile.bat

@echo off

cls&&cd ..\src && javac Affichage.java -d "../class" && javac Bateau.java -d "../class" && javac Case.java -d "../class" && javac Jeu.java -d "../class" && javac Joueur.java -d "../class" && javac Menu.java -d "../class" && javac Utilitaire.java -d "../class" && javac IA.java -d "../class" && cd ../BAT
cd ../BAT

# ./1.2 (Jeu finit)/BAT/Executer.bat

@echo off

c && java -cp "../class" Jeu


# ./1.2 (Jeu finit)/Jouer.bat

@echo off

c && java -cp "class" Jeu


# ./1.4 (Jeu finit (amÃ©liorÃ©), IA - en cours)/BAT/Compile et execute.bat

@echo off

cls&&cd ..\src && javac *.java -d "../class" && cd ../BAT && java -cp "../class" Jeu
cd ../BAT

# ./1.4 (Jeu finit (amÃ©liorÃ©), IA - en cours)/BAT/Compile.bat

@echo off

cls&&cd ..\src && javac Affichage.java -d "../class" && javac Bateau.java -d "../class" && javac Case.java -d "../class" && javac Jeu.java -d "../class" && javac Joueur.java -d "../class" && javac Menu.java -d "../class" && javac Utilitaire.java -d "../class" && javac IA.java -d "../class" && cd ../BAT
cd ../BAT

# ./1.4 (Jeu finit (amÃ©liorÃ©), IA - en cours)/BAT/Executer.bat

@echo off

c && java -cp "../class" Jeu


# ./1.4 (Jeu finit (amÃ©liorÃ©), IA - en cours)/Jouer.bat

@echo off

c && java -cp "class" Jeu


